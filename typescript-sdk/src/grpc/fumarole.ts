// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.12.4
// source: fumarole.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import {
  CommitmentLevel,
  commitmentLevelFromJSON,
  commitmentLevelToJSON,
  SubscribeRequestFilterAccounts,
  SubscribeRequestFilterBlocksMeta,
  SubscribeRequestFilterEntry,
  SubscribeRequestFilterTransactions,
  SubscribeUpdate,
} from "./geyser";

export const protobufPackage = "fumarole";

export enum InitialOffsetPolicy {
  /** LATEST - FROM_SLOT = 1; */
  LATEST = 0,
  UNRECOGNIZED = -1,
}

export function initialOffsetPolicyFromJSON(object: any): InitialOffsetPolicy {
  switch (object) {
    case 0:
    case "LATEST":
      return InitialOffsetPolicy.LATEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return InitialOffsetPolicy.UNRECOGNIZED;
  }
}

export function initialOffsetPolicyToJSON(object: InitialOffsetPolicy): string {
  switch (object) {
    case InitialOffsetPolicy.LATEST:
      return "LATEST";
    case InitialOffsetPolicy.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GetChainTipRequest {
  blockchainId: Uint8Array;
}

export interface GetChainTipResponse {
  blockchainId: Uint8Array;
  shardToMaxOffsetMap: { [key: number]: string };
}

export interface GetChainTipResponse_ShardToMaxOffsetMapEntry {
  key: number;
  value: string;
}

export interface VersionRequest {
}

export interface VersionResponse {
  version: string;
}

export interface GetConsumerGroupInfoRequest {
  consumerGroupName: string;
}

export interface DeleteConsumerGroupRequest {
  consumerGroupName: string;
}

export interface DeleteConsumerGroupResponse {
  success: boolean;
}

export interface ListConsumerGroupsRequest {
}

export interface ListConsumerGroupsResponse {
  consumerGroups: ConsumerGroupInfo[];
}

export interface ConsumerGroupInfo {
  id: string;
  consumerGroupName: string;
  isStale: boolean;
  blockchainId: Uint8Array;
}

export interface GetSlotLagInfoRequest {
  consumerGroupName: string;
}

export interface BlockFilters {
  accounts: { [key: string]: SubscribeRequestFilterAccounts };
  transactions: { [key: string]: SubscribeRequestFilterTransactions };
  entries: { [key: string]: SubscribeRequestFilterEntry };
  blocksMeta: { [key: string]: SubscribeRequestFilterBlocksMeta };
}

export interface BlockFilters_AccountsEntry {
  key: string;
  value: SubscribeRequestFilterAccounts | undefined;
}

export interface BlockFilters_TransactionsEntry {
  key: string;
  value: SubscribeRequestFilterTransactions | undefined;
}

export interface BlockFilters_EntriesEntry {
  key: string;
  value: SubscribeRequestFilterEntry | undefined;
}

export interface BlockFilters_BlocksMetaEntry {
  key: string;
  value: SubscribeRequestFilterBlocksMeta | undefined;
}

export interface DownloadBlockShard {
  blockchainId: Uint8Array;
  blockUid: Uint8Array;
  shardIdx: number;
  blockFilters?: BlockFilters | undefined;
}

export interface Ping {
  pingId: number;
}

export interface Pong {
  pingId: number;
}

export interface DataCommand {
  downloadBlockShard?: DownloadBlockShard | undefined;
  filterUpdate?: BlockFilters | undefined;
}

export interface BlockShardDownloadFinish {
}

export interface BlockNotFound {
  blockchainId: Uint8Array;
  blockUid: Uint8Array;
  shardIdx: number;
}

export interface DataError {
  notFound?: BlockNotFound | undefined;
}

export interface DataResponse {
  update?: SubscribeUpdate | undefined;
  blockShardDownloadFinish?: BlockShardDownloadFinish | undefined;
}

export interface CommitOffset {
  offset: string;
  shardId: number;
}

export interface PollBlockchainHistory {
  shardId: number;
  from?: string | undefined;
  limit?: string | undefined;
}

export interface BlockchainEvent {
  offset: string;
  blockchainId: Uint8Array;
  blockUid: Uint8Array;
  numShards: number;
  slot: string;
  parentSlot?: string | undefined;
  commitmentLevel: CommitmentLevel;
  blockchainShardId: number;
  deadError?: string | undefined;
}

export interface BlockchainHistory {
  events: BlockchainEvent[];
}

export interface JoinControlPlane {
  consumerGroupName?: string | undefined;
}

export interface ControlCommand {
  initialJoin?: JoinControlPlane | undefined;
  commitOffset?: CommitOffset | undefined;
  pollHist?: PollBlockchainHistory | undefined;
  ping?: Ping | undefined;
}

export interface ControlResponse {
  init?: InitialConsumerGroupState | undefined;
  commitOffset?: CommitOffsetResult | undefined;
  pollHist?: BlockchainHistory | undefined;
  pong?: Pong | undefined;
}

export interface CommitOffsetResult {
  offset: string;
  shardId: number;
}

export interface InitialConsumerGroupState {
  blockchainId: Uint8Array;
  lastCommittedOffsets: { [key: number]: string };
}

export interface InitialConsumerGroupState_LastCommittedOffsetsEntry {
  key: number;
  value: string;
}

export interface CreateConsumerGroupResponse {
  consumerGroupId: string;
}

export interface CreateConsumerGroupRequest {
  consumerGroupName: string;
  /** optional uint64 from_slot = 3; */
  initialOffsetPolicy: InitialOffsetPolicy;
}

function createBaseGetChainTipRequest(): GetChainTipRequest {
  return { blockchainId: new Uint8Array(0) };
}

export const GetChainTipRequest: MessageFns<GetChainTipRequest> = {
  encode(message: GetChainTipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockchainId.length !== 0) {
      writer.uint32(10).bytes(message.blockchainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainTipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainTipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainTipRequest {
    return { blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0) };
  },

  toJSON(message: GetChainTipRequest): unknown {
    const obj: any = {};
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainTipRequest>, I>>(base?: I): GetChainTipRequest {
    return GetChainTipRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainTipRequest>, I>>(object: I): GetChainTipRequest {
    const message = createBaseGetChainTipRequest();
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetChainTipResponse(): GetChainTipResponse {
  return { blockchainId: new Uint8Array(0), shardToMaxOffsetMap: {} };
}

export const GetChainTipResponse: MessageFns<GetChainTipResponse> = {
  encode(message: GetChainTipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockchainId.length !== 0) {
      writer.uint32(10).bytes(message.blockchainId);
    }
    Object.entries(message.shardToMaxOffsetMap).forEach(([key, value]) => {
      GetChainTipResponse_ShardToMaxOffsetMapEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainTipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainTipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = GetChainTipResponse_ShardToMaxOffsetMapEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.shardToMaxOffsetMap[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainTipResponse {
    return {
      blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
      shardToMaxOffsetMap: isObject(object.shardToMaxOffsetMap)
        ? Object.entries(object.shardToMaxOffsetMap).reduce<{ [key: number]: string }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: GetChainTipResponse): unknown {
    const obj: any = {};
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    if (message.shardToMaxOffsetMap) {
      const entries = Object.entries(message.shardToMaxOffsetMap);
      if (entries.length > 0) {
        obj.shardToMaxOffsetMap = {};
        entries.forEach(([k, v]) => {
          obj.shardToMaxOffsetMap[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainTipResponse>, I>>(base?: I): GetChainTipResponse {
    return GetChainTipResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainTipResponse>, I>>(object: I): GetChainTipResponse {
    const message = createBaseGetChainTipResponse();
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    message.shardToMaxOffsetMap = Object.entries(object.shardToMaxOffsetMap ?? {}).reduce<{ [key: number]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseGetChainTipResponse_ShardToMaxOffsetMapEntry(): GetChainTipResponse_ShardToMaxOffsetMapEntry {
  return { key: 0, value: "0" };
}

export const GetChainTipResponse_ShardToMaxOffsetMapEntry: MessageFns<GetChainTipResponse_ShardToMaxOffsetMapEntry> = {
  encode(
    message: GetChainTipResponse_ShardToMaxOffsetMapEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== "0") {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetChainTipResponse_ShardToMaxOffsetMapEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetChainTipResponse_ShardToMaxOffsetMapEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetChainTipResponse_ShardToMaxOffsetMapEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "0",
    };
  },

  toJSON(message: GetChainTipResponse_ShardToMaxOffsetMapEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== "0") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetChainTipResponse_ShardToMaxOffsetMapEntry>, I>>(
    base?: I,
  ): GetChainTipResponse_ShardToMaxOffsetMapEntry {
    return GetChainTipResponse_ShardToMaxOffsetMapEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetChainTipResponse_ShardToMaxOffsetMapEntry>, I>>(
    object: I,
  ): GetChainTipResponse_ShardToMaxOffsetMapEntry {
    const message = createBaseGetChainTipResponse_ShardToMaxOffsetMapEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseVersionRequest(): VersionRequest {
  return {};
}

export const VersionRequest: MessageFns<VersionRequest> = {
  encode(_: VersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): VersionRequest {
    return {};
  },

  toJSON(_: VersionRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionRequest>, I>>(base?: I): VersionRequest {
    return VersionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionRequest>, I>>(_: I): VersionRequest {
    const message = createBaseVersionRequest();
    return message;
  },
};

function createBaseVersionResponse(): VersionResponse {
  return { version: "" };
}

export const VersionResponse: MessageFns<VersionResponse> = {
  encode(message: VersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VersionResponse {
    return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
  },

  toJSON(message: VersionResponse): unknown {
    const obj: any = {};
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<VersionResponse>, I>>(base?: I): VersionResponse {
    return VersionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<VersionResponse>, I>>(object: I): VersionResponse {
    const message = createBaseVersionResponse();
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseGetConsumerGroupInfoRequest(): GetConsumerGroupInfoRequest {
  return { consumerGroupName: "" };
}

export const GetConsumerGroupInfoRequest: MessageFns<GetConsumerGroupInfoRequest> = {
  encode(message: GetConsumerGroupInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerGroupName !== "") {
      writer.uint32(10).string(message.consumerGroupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetConsumerGroupInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetConsumerGroupInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetConsumerGroupInfoRequest {
    return { consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "" };
  },

  toJSON(message: GetConsumerGroupInfoRequest): unknown {
    const obj: any = {};
    if (message.consumerGroupName !== "") {
      obj.consumerGroupName = message.consumerGroupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetConsumerGroupInfoRequest>, I>>(base?: I): GetConsumerGroupInfoRequest {
    return GetConsumerGroupInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetConsumerGroupInfoRequest>, I>>(object: I): GetConsumerGroupInfoRequest {
    const message = createBaseGetConsumerGroupInfoRequest();
    message.consumerGroupName = object.consumerGroupName ?? "";
    return message;
  },
};

function createBaseDeleteConsumerGroupRequest(): DeleteConsumerGroupRequest {
  return { consumerGroupName: "" };
}

export const DeleteConsumerGroupRequest: MessageFns<DeleteConsumerGroupRequest> = {
  encode(message: DeleteConsumerGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerGroupName !== "") {
      writer.uint32(10).string(message.consumerGroupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConsumerGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConsumerGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConsumerGroupRequest {
    return { consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "" };
  },

  toJSON(message: DeleteConsumerGroupRequest): unknown {
    const obj: any = {};
    if (message.consumerGroupName !== "") {
      obj.consumerGroupName = message.consumerGroupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConsumerGroupRequest>, I>>(base?: I): DeleteConsumerGroupRequest {
    return DeleteConsumerGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConsumerGroupRequest>, I>>(object: I): DeleteConsumerGroupRequest {
    const message = createBaseDeleteConsumerGroupRequest();
    message.consumerGroupName = object.consumerGroupName ?? "";
    return message;
  },
};

function createBaseDeleteConsumerGroupResponse(): DeleteConsumerGroupResponse {
  return { success: false };
}

export const DeleteConsumerGroupResponse: MessageFns<DeleteConsumerGroupResponse> = {
  encode(message: DeleteConsumerGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteConsumerGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteConsumerGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteConsumerGroupResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: DeleteConsumerGroupResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteConsumerGroupResponse>, I>>(base?: I): DeleteConsumerGroupResponse {
    return DeleteConsumerGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteConsumerGroupResponse>, I>>(object: I): DeleteConsumerGroupResponse {
    const message = createBaseDeleteConsumerGroupResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListConsumerGroupsRequest(): ListConsumerGroupsRequest {
  return {};
}

export const ListConsumerGroupsRequest: MessageFns<ListConsumerGroupsRequest> = {
  encode(_: ListConsumerGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConsumerGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConsumerGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListConsumerGroupsRequest {
    return {};
  },

  toJSON(_: ListConsumerGroupsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConsumerGroupsRequest>, I>>(base?: I): ListConsumerGroupsRequest {
    return ListConsumerGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConsumerGroupsRequest>, I>>(_: I): ListConsumerGroupsRequest {
    const message = createBaseListConsumerGroupsRequest();
    return message;
  },
};

function createBaseListConsumerGroupsResponse(): ListConsumerGroupsResponse {
  return { consumerGroups: [] };
}

export const ListConsumerGroupsResponse: MessageFns<ListConsumerGroupsResponse> = {
  encode(message: ListConsumerGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.consumerGroups) {
      ConsumerGroupInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListConsumerGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListConsumerGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroups.push(ConsumerGroupInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListConsumerGroupsResponse {
    return {
      consumerGroups: globalThis.Array.isArray(object?.consumerGroups)
        ? object.consumerGroups.map((e: any) => ConsumerGroupInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListConsumerGroupsResponse): unknown {
    const obj: any = {};
    if (message.consumerGroups?.length) {
      obj.consumerGroups = message.consumerGroups.map((e) => ConsumerGroupInfo.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListConsumerGroupsResponse>, I>>(base?: I): ListConsumerGroupsResponse {
    return ListConsumerGroupsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListConsumerGroupsResponse>, I>>(object: I): ListConsumerGroupsResponse {
    const message = createBaseListConsumerGroupsResponse();
    message.consumerGroups = object.consumerGroups?.map((e) => ConsumerGroupInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConsumerGroupInfo(): ConsumerGroupInfo {
  return { id: "", consumerGroupName: "", isStale: false, blockchainId: new Uint8Array(0) };
}

export const ConsumerGroupInfo: MessageFns<ConsumerGroupInfo> = {
  encode(message: ConsumerGroupInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.consumerGroupName !== "") {
      writer.uint32(18).string(message.consumerGroupName);
    }
    if (message.isStale !== false) {
      writer.uint32(24).bool(message.isStale);
    }
    if (message.blockchainId.length !== 0) {
      writer.uint32(34).bytes(message.blockchainId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsumerGroupInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsumerGroupInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.consumerGroupName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isStale = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsumerGroupInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "",
      isStale: isSet(object.isStale) ? globalThis.Boolean(object.isStale) : false,
      blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
    };
  },

  toJSON(message: ConsumerGroupInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.consumerGroupName !== "") {
      obj.consumerGroupName = message.consumerGroupName;
    }
    if (message.isStale !== false) {
      obj.isStale = message.isStale;
    }
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsumerGroupInfo>, I>>(base?: I): ConsumerGroupInfo {
    return ConsumerGroupInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsumerGroupInfo>, I>>(object: I): ConsumerGroupInfo {
    const message = createBaseConsumerGroupInfo();
    message.id = object.id ?? "";
    message.consumerGroupName = object.consumerGroupName ?? "";
    message.isStale = object.isStale ?? false;
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    return message;
  },
};

function createBaseGetSlotLagInfoRequest(): GetSlotLagInfoRequest {
  return { consumerGroupName: "" };
}

export const GetSlotLagInfoRequest: MessageFns<GetSlotLagInfoRequest> = {
  encode(message: GetSlotLagInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerGroupName !== "") {
      writer.uint32(10).string(message.consumerGroupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSlotLagInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSlotLagInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSlotLagInfoRequest {
    return { consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "" };
  },

  toJSON(message: GetSlotLagInfoRequest): unknown {
    const obj: any = {};
    if (message.consumerGroupName !== "") {
      obj.consumerGroupName = message.consumerGroupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetSlotLagInfoRequest>, I>>(base?: I): GetSlotLagInfoRequest {
    return GetSlotLagInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetSlotLagInfoRequest>, I>>(object: I): GetSlotLagInfoRequest {
    const message = createBaseGetSlotLagInfoRequest();
    message.consumerGroupName = object.consumerGroupName ?? "";
    return message;
  },
};

function createBaseBlockFilters(): BlockFilters {
  return { accounts: {}, transactions: {}, entries: {}, blocksMeta: {} };
}

export const BlockFilters: MessageFns<BlockFilters> = {
  encode(message: BlockFilters, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.accounts).forEach(([key, value]) => {
      BlockFilters_AccountsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.transactions).forEach(([key, value]) => {
      BlockFilters_TransactionsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.entries).forEach(([key, value]) => {
      BlockFilters_EntriesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.blocksMeta).forEach(([key, value]) => {
      BlockFilters_BlocksMetaEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockFilters {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockFilters();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = BlockFilters_AccountsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.accounts[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = BlockFilters_TransactionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.transactions[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = BlockFilters_EntriesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.entries[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = BlockFilters_BlocksMetaEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.blocksMeta[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockFilters {
    return {
      accounts: isObject(object.accounts)
        ? Object.entries(object.accounts).reduce<{ [key: string]: SubscribeRequestFilterAccounts }>(
          (acc, [key, value]) => {
            acc[key] = SubscribeRequestFilterAccounts.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      transactions: isObject(object.transactions)
        ? Object.entries(object.transactions).reduce<{ [key: string]: SubscribeRequestFilterTransactions }>(
          (acc, [key, value]) => {
            acc[key] = SubscribeRequestFilterTransactions.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      entries: isObject(object.entries)
        ? Object.entries(object.entries).reduce<{ [key: string]: SubscribeRequestFilterEntry }>((acc, [key, value]) => {
          acc[key] = SubscribeRequestFilterEntry.fromJSON(value);
          return acc;
        }, {})
        : {},
      blocksMeta: isObject(object.blocksMeta)
        ? Object.entries(object.blocksMeta).reduce<{ [key: string]: SubscribeRequestFilterBlocksMeta }>(
          (acc, [key, value]) => {
            acc[key] = SubscribeRequestFilterBlocksMeta.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
    };
  },

  toJSON(message: BlockFilters): unknown {
    const obj: any = {};
    if (message.accounts) {
      const entries = Object.entries(message.accounts);
      if (entries.length > 0) {
        obj.accounts = {};
        entries.forEach(([k, v]) => {
          obj.accounts[k] = SubscribeRequestFilterAccounts.toJSON(v);
        });
      }
    }
    if (message.transactions) {
      const entries = Object.entries(message.transactions);
      if (entries.length > 0) {
        obj.transactions = {};
        entries.forEach(([k, v]) => {
          obj.transactions[k] = SubscribeRequestFilterTransactions.toJSON(v);
        });
      }
    }
    if (message.entries) {
      const entries = Object.entries(message.entries);
      if (entries.length > 0) {
        obj.entries = {};
        entries.forEach(([k, v]) => {
          obj.entries[k] = SubscribeRequestFilterEntry.toJSON(v);
        });
      }
    }
    if (message.blocksMeta) {
      const entries = Object.entries(message.blocksMeta);
      if (entries.length > 0) {
        obj.blocksMeta = {};
        entries.forEach(([k, v]) => {
          obj.blocksMeta[k] = SubscribeRequestFilterBlocksMeta.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockFilters>, I>>(base?: I): BlockFilters {
    return BlockFilters.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockFilters>, I>>(object: I): BlockFilters {
    const message = createBaseBlockFilters();
    message.accounts = Object.entries(object.accounts ?? {}).reduce<{ [key: string]: SubscribeRequestFilterAccounts }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SubscribeRequestFilterAccounts.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.transactions = Object.entries(object.transactions ?? {}).reduce<
      { [key: string]: SubscribeRequestFilterTransactions }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SubscribeRequestFilterTransactions.fromPartial(value);
      }
      return acc;
    }, {});
    message.entries = Object.entries(object.entries ?? {}).reduce<{ [key: string]: SubscribeRequestFilterEntry }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = SubscribeRequestFilterEntry.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.blocksMeta = Object.entries(object.blocksMeta ?? {}).reduce<
      { [key: string]: SubscribeRequestFilterBlocksMeta }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = SubscribeRequestFilterBlocksMeta.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseBlockFilters_AccountsEntry(): BlockFilters_AccountsEntry {
  return { key: "", value: undefined };
}

export const BlockFilters_AccountsEntry: MessageFns<BlockFilters_AccountsEntry> = {
  encode(message: BlockFilters_AccountsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterAccounts.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockFilters_AccountsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockFilters_AccountsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterAccounts.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockFilters_AccountsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterAccounts.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BlockFilters_AccountsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterAccounts.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockFilters_AccountsEntry>, I>>(base?: I): BlockFilters_AccountsEntry {
    return BlockFilters_AccountsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockFilters_AccountsEntry>, I>>(object: I): BlockFilters_AccountsEntry {
    const message = createBaseBlockFilters_AccountsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterAccounts.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBlockFilters_TransactionsEntry(): BlockFilters_TransactionsEntry {
  return { key: "", value: undefined };
}

export const BlockFilters_TransactionsEntry: MessageFns<BlockFilters_TransactionsEntry> = {
  encode(message: BlockFilters_TransactionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterTransactions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockFilters_TransactionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockFilters_TransactionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterTransactions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockFilters_TransactionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterTransactions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BlockFilters_TransactionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterTransactions.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockFilters_TransactionsEntry>, I>>(base?: I): BlockFilters_TransactionsEntry {
    return BlockFilters_TransactionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockFilters_TransactionsEntry>, I>>(
    object: I,
  ): BlockFilters_TransactionsEntry {
    const message = createBaseBlockFilters_TransactionsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterTransactions.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBlockFilters_EntriesEntry(): BlockFilters_EntriesEntry {
  return { key: "", value: undefined };
}

export const BlockFilters_EntriesEntry: MessageFns<BlockFilters_EntriesEntry> = {
  encode(message: BlockFilters_EntriesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterEntry.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockFilters_EntriesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockFilters_EntriesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockFilters_EntriesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterEntry.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BlockFilters_EntriesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterEntry.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockFilters_EntriesEntry>, I>>(base?: I): BlockFilters_EntriesEntry {
    return BlockFilters_EntriesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockFilters_EntriesEntry>, I>>(object: I): BlockFilters_EntriesEntry {
    const message = createBaseBlockFilters_EntriesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterEntry.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseBlockFilters_BlocksMetaEntry(): BlockFilters_BlocksMetaEntry {
  return { key: "", value: undefined };
}

export const BlockFilters_BlocksMetaEntry: MessageFns<BlockFilters_BlocksMetaEntry> = {
  encode(message: BlockFilters_BlocksMetaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      SubscribeRequestFilterBlocksMeta.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockFilters_BlocksMetaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockFilters_BlocksMetaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SubscribeRequestFilterBlocksMeta.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockFilters_BlocksMetaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? SubscribeRequestFilterBlocksMeta.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: BlockFilters_BlocksMetaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = SubscribeRequestFilterBlocksMeta.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockFilters_BlocksMetaEntry>, I>>(base?: I): BlockFilters_BlocksMetaEntry {
    return BlockFilters_BlocksMetaEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockFilters_BlocksMetaEntry>, I>>(object: I): BlockFilters_BlocksMetaEntry {
    const message = createBaseBlockFilters_BlocksMetaEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? SubscribeRequestFilterBlocksMeta.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseDownloadBlockShard(): DownloadBlockShard {
  return { blockchainId: new Uint8Array(0), blockUid: new Uint8Array(0), shardIdx: 0, blockFilters: undefined };
}

export const DownloadBlockShard: MessageFns<DownloadBlockShard> = {
  encode(message: DownloadBlockShard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockchainId.length !== 0) {
      writer.uint32(10).bytes(message.blockchainId);
    }
    if (message.blockUid.length !== 0) {
      writer.uint32(18).bytes(message.blockUid);
    }
    if (message.shardIdx !== 0) {
      writer.uint32(24).int32(message.shardIdx);
    }
    if (message.blockFilters !== undefined) {
      BlockFilters.encode(message.blockFilters, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DownloadBlockShard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDownloadBlockShard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockUid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shardIdx = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockFilters = BlockFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DownloadBlockShard {
    return {
      blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
      blockUid: isSet(object.blockUid) ? bytesFromBase64(object.blockUid) : new Uint8Array(0),
      shardIdx: isSet(object.shardIdx) ? globalThis.Number(object.shardIdx) : 0,
      blockFilters: isSet(object.blockFilters) ? BlockFilters.fromJSON(object.blockFilters) : undefined,
    };
  },

  toJSON(message: DownloadBlockShard): unknown {
    const obj: any = {};
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    if (message.blockUid.length !== 0) {
      obj.blockUid = base64FromBytes(message.blockUid);
    }
    if (message.shardIdx !== 0) {
      obj.shardIdx = Math.round(message.shardIdx);
    }
    if (message.blockFilters !== undefined) {
      obj.blockFilters = BlockFilters.toJSON(message.blockFilters);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DownloadBlockShard>, I>>(base?: I): DownloadBlockShard {
    return DownloadBlockShard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DownloadBlockShard>, I>>(object: I): DownloadBlockShard {
    const message = createBaseDownloadBlockShard();
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    message.blockUid = object.blockUid ?? new Uint8Array(0);
    message.shardIdx = object.shardIdx ?? 0;
    message.blockFilters = (object.blockFilters !== undefined && object.blockFilters !== null)
      ? BlockFilters.fromPartial(object.blockFilters)
      : undefined;
    return message;
  },
};

function createBasePing(): Ping {
  return { pingId: 0 };
}

export const Ping: MessageFns<Ping> = {
  encode(message: Ping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pingId !== 0) {
      writer.uint32(8).uint32(message.pingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pingId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ping {
    return { pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : 0 };
  },

  toJSON(message: Ping): unknown {
    const obj: any = {};
    if (message.pingId !== 0) {
      obj.pingId = Math.round(message.pingId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ping>, I>>(base?: I): Ping {
    return Ping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ping>, I>>(object: I): Ping {
    const message = createBasePing();
    message.pingId = object.pingId ?? 0;
    return message;
  },
};

function createBasePong(): Pong {
  return { pingId: 0 };
}

export const Pong: MessageFns<Pong> = {
  encode(message: Pong, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pingId !== 0) {
      writer.uint32(8).uint32(message.pingId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pong {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.pingId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pong {
    return { pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : 0 };
  },

  toJSON(message: Pong): unknown {
    const obj: any = {};
    if (message.pingId !== 0) {
      obj.pingId = Math.round(message.pingId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pong>, I>>(base?: I): Pong {
    return Pong.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pong>, I>>(object: I): Pong {
    const message = createBasePong();
    message.pingId = object.pingId ?? 0;
    return message;
  },
};

function createBaseDataCommand(): DataCommand {
  return { downloadBlockShard: undefined, filterUpdate: undefined };
}

export const DataCommand: MessageFns<DataCommand> = {
  encode(message: DataCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.downloadBlockShard !== undefined) {
      DownloadBlockShard.encode(message.downloadBlockShard, writer.uint32(10).fork()).join();
    }
    if (message.filterUpdate !== undefined) {
      BlockFilters.encode(message.filterUpdate, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.downloadBlockShard = DownloadBlockShard.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filterUpdate = BlockFilters.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataCommand {
    return {
      downloadBlockShard: isSet(object.downloadBlockShard)
        ? DownloadBlockShard.fromJSON(object.downloadBlockShard)
        : undefined,
      filterUpdate: isSet(object.filterUpdate) ? BlockFilters.fromJSON(object.filterUpdate) : undefined,
    };
  },

  toJSON(message: DataCommand): unknown {
    const obj: any = {};
    if (message.downloadBlockShard !== undefined) {
      obj.downloadBlockShard = DownloadBlockShard.toJSON(message.downloadBlockShard);
    }
    if (message.filterUpdate !== undefined) {
      obj.filterUpdate = BlockFilters.toJSON(message.filterUpdate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataCommand>, I>>(base?: I): DataCommand {
    return DataCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataCommand>, I>>(object: I): DataCommand {
    const message = createBaseDataCommand();
    message.downloadBlockShard = (object.downloadBlockShard !== undefined && object.downloadBlockShard !== null)
      ? DownloadBlockShard.fromPartial(object.downloadBlockShard)
      : undefined;
    message.filterUpdate = (object.filterUpdate !== undefined && object.filterUpdate !== null)
      ? BlockFilters.fromPartial(object.filterUpdate)
      : undefined;
    return message;
  },
};

function createBaseBlockShardDownloadFinish(): BlockShardDownloadFinish {
  return {};
}

export const BlockShardDownloadFinish: MessageFns<BlockShardDownloadFinish> = {
  encode(_: BlockShardDownloadFinish, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockShardDownloadFinish {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockShardDownloadFinish();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): BlockShardDownloadFinish {
    return {};
  },

  toJSON(_: BlockShardDownloadFinish): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockShardDownloadFinish>, I>>(base?: I): BlockShardDownloadFinish {
    return BlockShardDownloadFinish.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockShardDownloadFinish>, I>>(_: I): BlockShardDownloadFinish {
    const message = createBaseBlockShardDownloadFinish();
    return message;
  },
};

function createBaseBlockNotFound(): BlockNotFound {
  return { blockchainId: new Uint8Array(0), blockUid: new Uint8Array(0), shardIdx: 0 };
}

export const BlockNotFound: MessageFns<BlockNotFound> = {
  encode(message: BlockNotFound, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockchainId.length !== 0) {
      writer.uint32(10).bytes(message.blockchainId);
    }
    if (message.blockUid.length !== 0) {
      writer.uint32(18).bytes(message.blockUid);
    }
    if (message.shardIdx !== 0) {
      writer.uint32(24).int32(message.shardIdx);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockNotFound {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockNotFound();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockUid = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.shardIdx = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockNotFound {
    return {
      blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
      blockUid: isSet(object.blockUid) ? bytesFromBase64(object.blockUid) : new Uint8Array(0),
      shardIdx: isSet(object.shardIdx) ? globalThis.Number(object.shardIdx) : 0,
    };
  },

  toJSON(message: BlockNotFound): unknown {
    const obj: any = {};
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    if (message.blockUid.length !== 0) {
      obj.blockUid = base64FromBytes(message.blockUid);
    }
    if (message.shardIdx !== 0) {
      obj.shardIdx = Math.round(message.shardIdx);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockNotFound>, I>>(base?: I): BlockNotFound {
    return BlockNotFound.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockNotFound>, I>>(object: I): BlockNotFound {
    const message = createBaseBlockNotFound();
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    message.blockUid = object.blockUid ?? new Uint8Array(0);
    message.shardIdx = object.shardIdx ?? 0;
    return message;
  },
};

function createBaseDataError(): DataError {
  return { notFound: undefined };
}

export const DataError: MessageFns<DataError> = {
  encode(message: DataError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.notFound !== undefined) {
      BlockNotFound.encode(message.notFound, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.notFound = BlockNotFound.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataError {
    return { notFound: isSet(object.notFound) ? BlockNotFound.fromJSON(object.notFound) : undefined };
  },

  toJSON(message: DataError): unknown {
    const obj: any = {};
    if (message.notFound !== undefined) {
      obj.notFound = BlockNotFound.toJSON(message.notFound);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataError>, I>>(base?: I): DataError {
    return DataError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataError>, I>>(object: I): DataError {
    const message = createBaseDataError();
    message.notFound = (object.notFound !== undefined && object.notFound !== null)
      ? BlockNotFound.fromPartial(object.notFound)
      : undefined;
    return message;
  },
};

function createBaseDataResponse(): DataResponse {
  return { update: undefined, blockShardDownloadFinish: undefined };
}

export const DataResponse: MessageFns<DataResponse> = {
  encode(message: DataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.update !== undefined) {
      SubscribeUpdate.encode(message.update, writer.uint32(10).fork()).join();
    }
    if (message.blockShardDownloadFinish !== undefined) {
      BlockShardDownloadFinish.encode(message.blockShardDownloadFinish, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.update = SubscribeUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockShardDownloadFinish = BlockShardDownloadFinish.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataResponse {
    return {
      update: isSet(object.update) ? SubscribeUpdate.fromJSON(object.update) : undefined,
      blockShardDownloadFinish: isSet(object.blockShardDownloadFinish)
        ? BlockShardDownloadFinish.fromJSON(object.blockShardDownloadFinish)
        : undefined,
    };
  },

  toJSON(message: DataResponse): unknown {
    const obj: any = {};
    if (message.update !== undefined) {
      obj.update = SubscribeUpdate.toJSON(message.update);
    }
    if (message.blockShardDownloadFinish !== undefined) {
      obj.blockShardDownloadFinish = BlockShardDownloadFinish.toJSON(message.blockShardDownloadFinish);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataResponse>, I>>(base?: I): DataResponse {
    return DataResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataResponse>, I>>(object: I): DataResponse {
    const message = createBaseDataResponse();
    message.update = (object.update !== undefined && object.update !== null)
      ? SubscribeUpdate.fromPartial(object.update)
      : undefined;
    message.blockShardDownloadFinish =
      (object.blockShardDownloadFinish !== undefined && object.blockShardDownloadFinish !== null)
        ? BlockShardDownloadFinish.fromPartial(object.blockShardDownloadFinish)
        : undefined;
    return message;
  },
};

function createBaseCommitOffset(): CommitOffset {
  return { offset: "0", shardId: 0 };
}

export const CommitOffset: MessageFns<CommitOffset> = {
  encode(message: CommitOffset, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== "0") {
      writer.uint32(8).int64(message.offset);
    }
    if (message.shardId !== 0) {
      writer.uint32(16).int32(message.shardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitOffset {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitOffset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.shardId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitOffset {
    return {
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
    };
  },

  toJSON(message: CommitOffset): unknown {
    const obj: any = {};
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.shardId !== 0) {
      obj.shardId = Math.round(message.shardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitOffset>, I>>(base?: I): CommitOffset {
    return CommitOffset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitOffset>, I>>(object: I): CommitOffset {
    const message = createBaseCommitOffset();
    message.offset = object.offset ?? "0";
    message.shardId = object.shardId ?? 0;
    return message;
  },
};

function createBasePollBlockchainHistory(): PollBlockchainHistory {
  return { shardId: 0, from: undefined, limit: undefined };
}

export const PollBlockchainHistory: MessageFns<PollBlockchainHistory> = {
  encode(message: PollBlockchainHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shardId !== 0) {
      writer.uint32(8).int32(message.shardId);
    }
    if (message.from !== undefined) {
      writer.uint32(16).int64(message.from);
    }
    if (message.limit !== undefined) {
      writer.uint32(24).int64(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PollBlockchainHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePollBlockchainHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shardId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.from = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PollBlockchainHistory {
    return {
      shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
      from: isSet(object.from) ? globalThis.String(object.from) : undefined,
      limit: isSet(object.limit) ? globalThis.String(object.limit) : undefined,
    };
  },

  toJSON(message: PollBlockchainHistory): unknown {
    const obj: any = {};
    if (message.shardId !== 0) {
      obj.shardId = Math.round(message.shardId);
    }
    if (message.from !== undefined) {
      obj.from = message.from;
    }
    if (message.limit !== undefined) {
      obj.limit = message.limit;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PollBlockchainHistory>, I>>(base?: I): PollBlockchainHistory {
    return PollBlockchainHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PollBlockchainHistory>, I>>(object: I): PollBlockchainHistory {
    const message = createBasePollBlockchainHistory();
    message.shardId = object.shardId ?? 0;
    message.from = object.from ?? undefined;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseBlockchainEvent(): BlockchainEvent {
  return {
    offset: "0",
    blockchainId: new Uint8Array(0),
    blockUid: new Uint8Array(0),
    numShards: 0,
    slot: "0",
    parentSlot: undefined,
    commitmentLevel: 0,
    blockchainShardId: 0,
    deadError: undefined,
  };
}

export const BlockchainEvent: MessageFns<BlockchainEvent> = {
  encode(message: BlockchainEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== "0") {
      writer.uint32(8).int64(message.offset);
    }
    if (message.blockchainId.length !== 0) {
      writer.uint32(18).bytes(message.blockchainId);
    }
    if (message.blockUid.length !== 0) {
      writer.uint32(26).bytes(message.blockUid);
    }
    if (message.numShards !== 0) {
      writer.uint32(32).uint32(message.numShards);
    }
    if (message.slot !== "0") {
      writer.uint32(40).uint64(message.slot);
    }
    if (message.parentSlot !== undefined) {
      writer.uint32(48).uint64(message.parentSlot);
    }
    if (message.commitmentLevel !== 0) {
      writer.uint32(56).int32(message.commitmentLevel);
    }
    if (message.blockchainShardId !== 0) {
      writer.uint32(64).int32(message.blockchainShardId);
    }
    if (message.deadError !== undefined) {
      writer.uint32(74).string(message.deadError);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockUid = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numShards = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slot = reader.uint64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.parentSlot = reader.uint64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.commitmentLevel = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.blockchainShardId = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.deadError = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainEvent {
    return {
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
      blockUid: isSet(object.blockUid) ? bytesFromBase64(object.blockUid) : new Uint8Array(0),
      numShards: isSet(object.numShards) ? globalThis.Number(object.numShards) : 0,
      slot: isSet(object.slot) ? globalThis.String(object.slot) : "0",
      parentSlot: isSet(object.parentSlot) ? globalThis.String(object.parentSlot) : undefined,
      commitmentLevel: isSet(object.commitmentLevel) ? commitmentLevelFromJSON(object.commitmentLevel) : 0,
      blockchainShardId: isSet(object.blockchainShardId) ? globalThis.Number(object.blockchainShardId) : 0,
      deadError: isSet(object.deadError) ? globalThis.String(object.deadError) : undefined,
    };
  },

  toJSON(message: BlockchainEvent): unknown {
    const obj: any = {};
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    if (message.blockUid.length !== 0) {
      obj.blockUid = base64FromBytes(message.blockUid);
    }
    if (message.numShards !== 0) {
      obj.numShards = Math.round(message.numShards);
    }
    if (message.slot !== "0") {
      obj.slot = message.slot;
    }
    if (message.parentSlot !== undefined) {
      obj.parentSlot = message.parentSlot;
    }
    if (message.commitmentLevel !== 0) {
      obj.commitmentLevel = commitmentLevelToJSON(message.commitmentLevel);
    }
    if (message.blockchainShardId !== 0) {
      obj.blockchainShardId = Math.round(message.blockchainShardId);
    }
    if (message.deadError !== undefined) {
      obj.deadError = message.deadError;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockchainEvent>, I>>(base?: I): BlockchainEvent {
    return BlockchainEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockchainEvent>, I>>(object: I): BlockchainEvent {
    const message = createBaseBlockchainEvent();
    message.offset = object.offset ?? "0";
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    message.blockUid = object.blockUid ?? new Uint8Array(0);
    message.numShards = object.numShards ?? 0;
    message.slot = object.slot ?? "0";
    message.parentSlot = object.parentSlot ?? undefined;
    message.commitmentLevel = object.commitmentLevel ?? 0;
    message.blockchainShardId = object.blockchainShardId ?? 0;
    message.deadError = object.deadError ?? undefined;
    return message;
  },
};

function createBaseBlockchainHistory(): BlockchainHistory {
  return { events: [] };
}

export const BlockchainHistory: MessageFns<BlockchainHistory> = {
  encode(message: BlockchainHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      BlockchainEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BlockchainHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBlockchainHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(BlockchainEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BlockchainHistory {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => BlockchainEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BlockchainHistory): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => BlockchainEvent.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BlockchainHistory>, I>>(base?: I): BlockchainHistory {
    return BlockchainHistory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BlockchainHistory>, I>>(object: I): BlockchainHistory {
    const message = createBaseBlockchainHistory();
    message.events = object.events?.map((e) => BlockchainEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseJoinControlPlane(): JoinControlPlane {
  return { consumerGroupName: undefined };
}

export const JoinControlPlane: MessageFns<JoinControlPlane> = {
  encode(message: JoinControlPlane, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerGroupName !== undefined) {
      writer.uint32(10).string(message.consumerGroupName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinControlPlane {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinControlPlane();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroupName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinControlPlane {
    return {
      consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : undefined,
    };
  },

  toJSON(message: JoinControlPlane): unknown {
    const obj: any = {};
    if (message.consumerGroupName !== undefined) {
      obj.consumerGroupName = message.consumerGroupName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinControlPlane>, I>>(base?: I): JoinControlPlane {
    return JoinControlPlane.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinControlPlane>, I>>(object: I): JoinControlPlane {
    const message = createBaseJoinControlPlane();
    message.consumerGroupName = object.consumerGroupName ?? undefined;
    return message;
  },
};

function createBaseControlCommand(): ControlCommand {
  return { initialJoin: undefined, commitOffset: undefined, pollHist: undefined, ping: undefined };
}

export const ControlCommand: MessageFns<ControlCommand> = {
  encode(message: ControlCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialJoin !== undefined) {
      JoinControlPlane.encode(message.initialJoin, writer.uint32(10).fork()).join();
    }
    if (message.commitOffset !== undefined) {
      CommitOffset.encode(message.commitOffset, writer.uint32(18).fork()).join();
    }
    if (message.pollHist !== undefined) {
      PollBlockchainHistory.encode(message.pollHist, writer.uint32(26).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initialJoin = JoinControlPlane.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commitOffset = CommitOffset.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pollHist = PollBlockchainHistory.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlCommand {
    return {
      initialJoin: isSet(object.initialJoin) ? JoinControlPlane.fromJSON(object.initialJoin) : undefined,
      commitOffset: isSet(object.commitOffset) ? CommitOffset.fromJSON(object.commitOffset) : undefined,
      pollHist: isSet(object.pollHist) ? PollBlockchainHistory.fromJSON(object.pollHist) : undefined,
      ping: isSet(object.ping) ? Ping.fromJSON(object.ping) : undefined,
    };
  },

  toJSON(message: ControlCommand): unknown {
    const obj: any = {};
    if (message.initialJoin !== undefined) {
      obj.initialJoin = JoinControlPlane.toJSON(message.initialJoin);
    }
    if (message.commitOffset !== undefined) {
      obj.commitOffset = CommitOffset.toJSON(message.commitOffset);
    }
    if (message.pollHist !== undefined) {
      obj.pollHist = PollBlockchainHistory.toJSON(message.pollHist);
    }
    if (message.ping !== undefined) {
      obj.ping = Ping.toJSON(message.ping);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlCommand>, I>>(base?: I): ControlCommand {
    return ControlCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlCommand>, I>>(object: I): ControlCommand {
    const message = createBaseControlCommand();
    message.initialJoin = (object.initialJoin !== undefined && object.initialJoin !== null)
      ? JoinControlPlane.fromPartial(object.initialJoin)
      : undefined;
    message.commitOffset = (object.commitOffset !== undefined && object.commitOffset !== null)
      ? CommitOffset.fromPartial(object.commitOffset)
      : undefined;
    message.pollHist = (object.pollHist !== undefined && object.pollHist !== null)
      ? PollBlockchainHistory.fromPartial(object.pollHist)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    return message;
  },
};

function createBaseControlResponse(): ControlResponse {
  return { init: undefined, commitOffset: undefined, pollHist: undefined, pong: undefined };
}

export const ControlResponse: MessageFns<ControlResponse> = {
  encode(message: ControlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.init !== undefined) {
      InitialConsumerGroupState.encode(message.init, writer.uint32(10).fork()).join();
    }
    if (message.commitOffset !== undefined) {
      CommitOffsetResult.encode(message.commitOffset, writer.uint32(18).fork()).join();
    }
    if (message.pollHist !== undefined) {
      BlockchainHistory.encode(message.pollHist, writer.uint32(26).fork()).join();
    }
    if (message.pong !== undefined) {
      Pong.encode(message.pong, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.init = InitialConsumerGroupState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commitOffset = CommitOffsetResult.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pollHist = BlockchainHistory.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pong = Pong.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlResponse {
    return {
      init: isSet(object.init) ? InitialConsumerGroupState.fromJSON(object.init) : undefined,
      commitOffset: isSet(object.commitOffset) ? CommitOffsetResult.fromJSON(object.commitOffset) : undefined,
      pollHist: isSet(object.pollHist) ? BlockchainHistory.fromJSON(object.pollHist) : undefined,
      pong: isSet(object.pong) ? Pong.fromJSON(object.pong) : undefined,
    };
  },

  toJSON(message: ControlResponse): unknown {
    const obj: any = {};
    if (message.init !== undefined) {
      obj.init = InitialConsumerGroupState.toJSON(message.init);
    }
    if (message.commitOffset !== undefined) {
      obj.commitOffset = CommitOffsetResult.toJSON(message.commitOffset);
    }
    if (message.pollHist !== undefined) {
      obj.pollHist = BlockchainHistory.toJSON(message.pollHist);
    }
    if (message.pong !== undefined) {
      obj.pong = Pong.toJSON(message.pong);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlResponse>, I>>(base?: I): ControlResponse {
    return ControlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlResponse>, I>>(object: I): ControlResponse {
    const message = createBaseControlResponse();
    message.init = (object.init !== undefined && object.init !== null)
      ? InitialConsumerGroupState.fromPartial(object.init)
      : undefined;
    message.commitOffset = (object.commitOffset !== undefined && object.commitOffset !== null)
      ? CommitOffsetResult.fromPartial(object.commitOffset)
      : undefined;
    message.pollHist = (object.pollHist !== undefined && object.pollHist !== null)
      ? BlockchainHistory.fromPartial(object.pollHist)
      : undefined;
    message.pong = (object.pong !== undefined && object.pong !== null) ? Pong.fromPartial(object.pong) : undefined;
    return message;
  },
};

function createBaseCommitOffsetResult(): CommitOffsetResult {
  return { offset: "0", shardId: 0 };
}

export const CommitOffsetResult: MessageFns<CommitOffsetResult> = {
  encode(message: CommitOffsetResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offset !== "0") {
      writer.uint32(8).int64(message.offset);
    }
    if (message.shardId !== 0) {
      writer.uint32(16).int32(message.shardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommitOffsetResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommitOffsetResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.offset = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.shardId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommitOffsetResult {
    return {
      offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
      shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
    };
  },

  toJSON(message: CommitOffsetResult): unknown {
    const obj: any = {};
    if (message.offset !== "0") {
      obj.offset = message.offset;
    }
    if (message.shardId !== 0) {
      obj.shardId = Math.round(message.shardId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommitOffsetResult>, I>>(base?: I): CommitOffsetResult {
    return CommitOffsetResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommitOffsetResult>, I>>(object: I): CommitOffsetResult {
    const message = createBaseCommitOffsetResult();
    message.offset = object.offset ?? "0";
    message.shardId = object.shardId ?? 0;
    return message;
  },
};

function createBaseInitialConsumerGroupState(): InitialConsumerGroupState {
  return { blockchainId: new Uint8Array(0), lastCommittedOffsets: {} };
}

export const InitialConsumerGroupState: MessageFns<InitialConsumerGroupState> = {
  encode(message: InitialConsumerGroupState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blockchainId.length !== 0) {
      writer.uint32(10).bytes(message.blockchainId);
    }
    Object.entries(message.lastCommittedOffsets).forEach(([key, value]) => {
      InitialConsumerGroupState_LastCommittedOffsetsEntry.encode({ key: key as any, value }, writer.uint32(18).fork())
        .join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialConsumerGroupState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialConsumerGroupState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blockchainId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = InitialConsumerGroupState_LastCommittedOffsetsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.lastCommittedOffsets[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialConsumerGroupState {
    return {
      blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
      lastCommittedOffsets: isObject(object.lastCommittedOffsets)
        ? Object.entries(object.lastCommittedOffsets).reduce<{ [key: number]: string }>((acc, [key, value]) => {
          acc[globalThis.Number(key)] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: InitialConsumerGroupState): unknown {
    const obj: any = {};
    if (message.blockchainId.length !== 0) {
      obj.blockchainId = base64FromBytes(message.blockchainId);
    }
    if (message.lastCommittedOffsets) {
      const entries = Object.entries(message.lastCommittedOffsets);
      if (entries.length > 0) {
        obj.lastCommittedOffsets = {};
        entries.forEach(([k, v]) => {
          obj.lastCommittedOffsets[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitialConsumerGroupState>, I>>(base?: I): InitialConsumerGroupState {
    return InitialConsumerGroupState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitialConsumerGroupState>, I>>(object: I): InitialConsumerGroupState {
    const message = createBaseInitialConsumerGroupState();
    message.blockchainId = object.blockchainId ?? new Uint8Array(0);
    message.lastCommittedOffsets = Object.entries(object.lastCommittedOffsets ?? {}).reduce<{ [key: number]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[globalThis.Number(key)] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseInitialConsumerGroupState_LastCommittedOffsetsEntry(): InitialConsumerGroupState_LastCommittedOffsetsEntry {
  return { key: 0, value: "0" };
}

export const InitialConsumerGroupState_LastCommittedOffsetsEntry: MessageFns<
  InitialConsumerGroupState_LastCommittedOffsetsEntry
> = {
  encode(
    message: InitialConsumerGroupState_LastCommittedOffsetsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== "0") {
      writer.uint32(16).int64(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitialConsumerGroupState_LastCommittedOffsetsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitialConsumerGroupState_LastCommittedOffsetsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitialConsumerGroupState_LastCommittedOffsetsEntry {
    return {
      key: isSet(object.key) ? globalThis.Number(object.key) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "0",
    };
  },

  toJSON(message: InitialConsumerGroupState_LastCommittedOffsetsEntry): unknown {
    const obj: any = {};
    if (message.key !== 0) {
      obj.key = Math.round(message.key);
    }
    if (message.value !== "0") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitialConsumerGroupState_LastCommittedOffsetsEntry>, I>>(
    base?: I,
  ): InitialConsumerGroupState_LastCommittedOffsetsEntry {
    return InitialConsumerGroupState_LastCommittedOffsetsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitialConsumerGroupState_LastCommittedOffsetsEntry>, I>>(
    object: I,
  ): InitialConsumerGroupState_LastCommittedOffsetsEntry {
    const message = createBaseInitialConsumerGroupState_LastCommittedOffsetsEntry();
    message.key = object.key ?? 0;
    message.value = object.value ?? "0";
    return message;
  },
};

function createBaseCreateConsumerGroupResponse(): CreateConsumerGroupResponse {
  return { consumerGroupId: "" };
}

export const CreateConsumerGroupResponse: MessageFns<CreateConsumerGroupResponse> = {
  encode(message: CreateConsumerGroupResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerGroupId !== "") {
      writer.uint32(10).string(message.consumerGroupId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConsumerGroupResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConsumerGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroupId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConsumerGroupResponse {
    return { consumerGroupId: isSet(object.consumerGroupId) ? globalThis.String(object.consumerGroupId) : "" };
  },

  toJSON(message: CreateConsumerGroupResponse): unknown {
    const obj: any = {};
    if (message.consumerGroupId !== "") {
      obj.consumerGroupId = message.consumerGroupId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConsumerGroupResponse>, I>>(base?: I): CreateConsumerGroupResponse {
    return CreateConsumerGroupResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConsumerGroupResponse>, I>>(object: I): CreateConsumerGroupResponse {
    const message = createBaseCreateConsumerGroupResponse();
    message.consumerGroupId = object.consumerGroupId ?? "";
    return message;
  },
};

function createBaseCreateConsumerGroupRequest(): CreateConsumerGroupRequest {
  return { consumerGroupName: "", initialOffsetPolicy: 0 };
}

export const CreateConsumerGroupRequest: MessageFns<CreateConsumerGroupRequest> = {
  encode(message: CreateConsumerGroupRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consumerGroupName !== "") {
      writer.uint32(10).string(message.consumerGroupName);
    }
    if (message.initialOffsetPolicy !== 0) {
      writer.uint32(16).int32(message.initialOffsetPolicy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateConsumerGroupRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateConsumerGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.consumerGroupName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.initialOffsetPolicy = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateConsumerGroupRequest {
    return {
      consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "",
      initialOffsetPolicy: isSet(object.initialOffsetPolicy)
        ? initialOffsetPolicyFromJSON(object.initialOffsetPolicy)
        : 0,
    };
  },

  toJSON(message: CreateConsumerGroupRequest): unknown {
    const obj: any = {};
    if (message.consumerGroupName !== "") {
      obj.consumerGroupName = message.consumerGroupName;
    }
    if (message.initialOffsetPolicy !== 0) {
      obj.initialOffsetPolicy = initialOffsetPolicyToJSON(message.initialOffsetPolicy);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateConsumerGroupRequest>, I>>(base?: I): CreateConsumerGroupRequest {
    return CreateConsumerGroupRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateConsumerGroupRequest>, I>>(object: I): CreateConsumerGroupRequest {
    const message = createBaseCreateConsumerGroupRequest();
    message.consumerGroupName = object.consumerGroupName ?? "";
    message.initialOffsetPolicy = object.initialOffsetPolicy ?? 0;
    return message;
  },
};

export type FumaroleService = typeof FumaroleService;
export const FumaroleService = {
  getConsumerGroupInfo: {
    path: "/fumarole.Fumarole/GetConsumerGroupInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetConsumerGroupInfoRequest): Buffer =>
      Buffer.from(GetConsumerGroupInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetConsumerGroupInfoRequest => GetConsumerGroupInfoRequest.decode(value),
    responseSerialize: (value: ConsumerGroupInfo): Buffer => Buffer.from(ConsumerGroupInfo.encode(value).finish()),
    responseDeserialize: (value: Buffer): ConsumerGroupInfo => ConsumerGroupInfo.decode(value),
  },
  listConsumerGroups: {
    path: "/fumarole.Fumarole/ListConsumerGroups",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListConsumerGroupsRequest): Buffer =>
      Buffer.from(ListConsumerGroupsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListConsumerGroupsRequest => ListConsumerGroupsRequest.decode(value),
    responseSerialize: (value: ListConsumerGroupsResponse): Buffer =>
      Buffer.from(ListConsumerGroupsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListConsumerGroupsResponse => ListConsumerGroupsResponse.decode(value),
  },
  deleteConsumerGroup: {
    path: "/fumarole.Fumarole/DeleteConsumerGroup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteConsumerGroupRequest): Buffer =>
      Buffer.from(DeleteConsumerGroupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteConsumerGroupRequest => DeleteConsumerGroupRequest.decode(value),
    responseSerialize: (value: DeleteConsumerGroupResponse): Buffer =>
      Buffer.from(DeleteConsumerGroupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteConsumerGroupResponse => DeleteConsumerGroupResponse.decode(value),
  },
  createConsumerGroup: {
    path: "/fumarole.Fumarole/CreateConsumerGroup",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateConsumerGroupRequest): Buffer =>
      Buffer.from(CreateConsumerGroupRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateConsumerGroupRequest => CreateConsumerGroupRequest.decode(value),
    responseSerialize: (value: CreateConsumerGroupResponse): Buffer =>
      Buffer.from(CreateConsumerGroupResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateConsumerGroupResponse => CreateConsumerGroupResponse.decode(value),
  },
  downloadBlock: {
    path: "/fumarole.Fumarole/DownloadBlock",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: DownloadBlockShard): Buffer => Buffer.from(DownloadBlockShard.encode(value).finish()),
    requestDeserialize: (value: Buffer): DownloadBlockShard => DownloadBlockShard.decode(value),
    responseSerialize: (value: DataResponse): Buffer => Buffer.from(DataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DataResponse => DataResponse.decode(value),
  },
  /** Represents subscription to the data plane */
  subscribeData: {
    path: "/fumarole.Fumarole/SubscribeData",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: DataCommand): Buffer => Buffer.from(DataCommand.encode(value).finish()),
    requestDeserialize: (value: Buffer): DataCommand => DataCommand.decode(value),
    responseSerialize: (value: DataResponse): Buffer => Buffer.from(DataResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DataResponse => DataResponse.decode(value),
  },
  getChainTip: {
    path: "/fumarole.Fumarole/GetChainTip",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetChainTipRequest): Buffer => Buffer.from(GetChainTipRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetChainTipRequest => GetChainTipRequest.decode(value),
    responseSerialize: (value: GetChainTipResponse): Buffer => Buffer.from(GetChainTipResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetChainTipResponse => GetChainTipResponse.decode(value),
  },
  /** Represents subscription to the control plane */
  subscribe: {
    path: "/fumarole.Fumarole/Subscribe",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ControlCommand): Buffer => Buffer.from(ControlCommand.encode(value).finish()),
    requestDeserialize: (value: Buffer): ControlCommand => ControlCommand.decode(value),
    responseSerialize: (value: ControlResponse): Buffer => Buffer.from(ControlResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ControlResponse => ControlResponse.decode(value),
  },
  version: {
    path: "/fumarole.Fumarole/Version",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: VersionRequest): Buffer => Buffer.from(VersionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): VersionRequest => VersionRequest.decode(value),
    responseSerialize: (value: VersionResponse): Buffer => Buffer.from(VersionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): VersionResponse => VersionResponse.decode(value),
  },
} as const;

export interface FumaroleServer extends UntypedServiceImplementation {
  getConsumerGroupInfo: handleUnaryCall<GetConsumerGroupInfoRequest, ConsumerGroupInfo>;
  listConsumerGroups: handleUnaryCall<ListConsumerGroupsRequest, ListConsumerGroupsResponse>;
  deleteConsumerGroup: handleUnaryCall<DeleteConsumerGroupRequest, DeleteConsumerGroupResponse>;
  createConsumerGroup: handleUnaryCall<CreateConsumerGroupRequest, CreateConsumerGroupResponse>;
  downloadBlock: handleServerStreamingCall<DownloadBlockShard, DataResponse>;
  /** Represents subscription to the data plane */
  subscribeData: handleBidiStreamingCall<DataCommand, DataResponse>;
  getChainTip: handleUnaryCall<GetChainTipRequest, GetChainTipResponse>;
  /** Represents subscription to the control plane */
  subscribe: handleBidiStreamingCall<ControlCommand, ControlResponse>;
  version: handleUnaryCall<VersionRequest, VersionResponse>;
}

export interface FumaroleClient extends Client {
  getConsumerGroupInfo(
    request: GetConsumerGroupInfoRequest,
    callback: (error: ServiceError | null, response: ConsumerGroupInfo) => void,
  ): ClientUnaryCall;
  getConsumerGroupInfo(
    request: GetConsumerGroupInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ConsumerGroupInfo) => void,
  ): ClientUnaryCall;
  getConsumerGroupInfo(
    request: GetConsumerGroupInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ConsumerGroupInfo) => void,
  ): ClientUnaryCall;
  listConsumerGroups(
    request: ListConsumerGroupsRequest,
    callback: (error: ServiceError | null, response: ListConsumerGroupsResponse) => void,
  ): ClientUnaryCall;
  listConsumerGroups(
    request: ListConsumerGroupsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListConsumerGroupsResponse) => void,
  ): ClientUnaryCall;
  listConsumerGroups(
    request: ListConsumerGroupsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListConsumerGroupsResponse) => void,
  ): ClientUnaryCall;
  deleteConsumerGroup(
    request: DeleteConsumerGroupRequest,
    callback: (error: ServiceError | null, response: DeleteConsumerGroupResponse) => void,
  ): ClientUnaryCall;
  deleteConsumerGroup(
    request: DeleteConsumerGroupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DeleteConsumerGroupResponse) => void,
  ): ClientUnaryCall;
  deleteConsumerGroup(
    request: DeleteConsumerGroupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DeleteConsumerGroupResponse) => void,
  ): ClientUnaryCall;
  createConsumerGroup(
    request: CreateConsumerGroupRequest,
    callback: (error: ServiceError | null, response: CreateConsumerGroupResponse) => void,
  ): ClientUnaryCall;
  createConsumerGroup(
    request: CreateConsumerGroupRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateConsumerGroupResponse) => void,
  ): ClientUnaryCall;
  createConsumerGroup(
    request: CreateConsumerGroupRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateConsumerGroupResponse) => void,
  ): ClientUnaryCall;
  downloadBlock(request: DownloadBlockShard, options?: Partial<CallOptions>): ClientReadableStream<DataResponse>;
  downloadBlock(
    request: DownloadBlockShard,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<DataResponse>;
  /** Represents subscription to the data plane */
  subscribeData(): ClientDuplexStream<DataCommand, DataResponse>;
  subscribeData(options: Partial<CallOptions>): ClientDuplexStream<DataCommand, DataResponse>;
  subscribeData(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<DataCommand, DataResponse>;
  getChainTip(
    request: GetChainTipRequest,
    callback: (error: ServiceError | null, response: GetChainTipResponse) => void,
  ): ClientUnaryCall;
  getChainTip(
    request: GetChainTipRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetChainTipResponse) => void,
  ): ClientUnaryCall;
  getChainTip(
    request: GetChainTipRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetChainTipResponse) => void,
  ): ClientUnaryCall;
  /** Represents subscription to the control plane */
  subscribe(): ClientDuplexStream<ControlCommand, ControlResponse>;
  subscribe(options: Partial<CallOptions>): ClientDuplexStream<ControlCommand, ControlResponse>;
  subscribe(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<ControlCommand, ControlResponse>;
  version(
    request: VersionRequest,
    callback: (error: ServiceError | null, response: VersionResponse) => void,
  ): ClientUnaryCall;
  version(
    request: VersionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: VersionResponse) => void,
  ): ClientUnaryCall;
  version(
    request: VersionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: VersionResponse) => void,
  ): ClientUnaryCall;
}

export const FumaroleClient = makeGenericClientConstructor(FumaroleService, "fumarole.Fumarole") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): FumaroleClient;
  service: typeof FumaroleService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
