"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v3.12.4
// source: fumarole.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.FumaroleClient = exports.FumaroleService = exports.CreateConsumerGroupRequest = exports.CreateConsumerGroupResponse = exports.InitialConsumerGroupState_LastCommittedOffsetsEntry = exports.InitialConsumerGroupState = exports.CommitOffsetResult = exports.ControlResponse = exports.ControlCommand = exports.JoinControlPlane = exports.BlockchainHistory = exports.BlockchainEvent = exports.PollBlockchainHistory = exports.CommitOffset = exports.DataResponse = exports.DataError = exports.BlockNotFound = exports.BlockShardDownloadFinish = exports.DataCommand = exports.Pong = exports.Ping = exports.DownloadBlockShard = exports.BlockFilters_BlocksMetaEntry = exports.BlockFilters_EntriesEntry = exports.BlockFilters_TransactionsEntry = exports.BlockFilters_AccountsEntry = exports.BlockFilters = exports.GetSlotLagInfoRequest = exports.ConsumerGroupInfo = exports.ListConsumerGroupsResponse = exports.ListConsumerGroupsRequest = exports.DeleteConsumerGroupResponse = exports.DeleteConsumerGroupRequest = exports.GetConsumerGroupInfoRequest = exports.VersionResponse = exports.VersionRequest = exports.GetChainTipResponse_ShardToMaxOffsetMapEntry = exports.GetChainTipResponse = exports.GetChainTipRequest = exports.InitialOffsetPolicy = exports.protobufPackage = void 0;
exports.initialOffsetPolicyFromJSON = initialOffsetPolicyFromJSON;
exports.initialOffsetPolicyToJSON = initialOffsetPolicyToJSON;
/* eslint-disable */
var wire_1 = require("@bufbuild/protobuf/wire");
var grpc_js_1 = require("@grpc/grpc-js");
var geyser_1 = require("./geyser");
exports.protobufPackage = "fumarole";
var InitialOffsetPolicy;
(function (InitialOffsetPolicy) {
    /** LATEST - FROM_SLOT = 1; */
    InitialOffsetPolicy[InitialOffsetPolicy["LATEST"] = 0] = "LATEST";
    InitialOffsetPolicy[InitialOffsetPolicy["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(InitialOffsetPolicy || (exports.InitialOffsetPolicy = InitialOffsetPolicy = {}));
function initialOffsetPolicyFromJSON(object) {
    switch (object) {
        case 0:
        case "LATEST":
            return InitialOffsetPolicy.LATEST;
        case -1:
        case "UNRECOGNIZED":
        default:
            return InitialOffsetPolicy.UNRECOGNIZED;
    }
}
function initialOffsetPolicyToJSON(object) {
    switch (object) {
        case InitialOffsetPolicy.LATEST:
            return "LATEST";
        case InitialOffsetPolicy.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseGetChainTipRequest() {
    return { blockchainId: new Uint8Array(0) };
}
exports.GetChainTipRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.blockchainId.length !== 0) {
            writer.uint32(10).bytes(message.blockchainId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetChainTipRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0) };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        return obj;
    },
    create: function (base) {
        return exports.GetChainTipRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseGetChainTipRequest();
        message.blockchainId = (_a = object.blockchainId) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        return message;
    },
};
function createBaseGetChainTipResponse() {
    return { blockchainId: new Uint8Array(0), shardToMaxOffsetMap: {} };
}
exports.GetChainTipResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.blockchainId.length !== 0) {
            writer.uint32(10).bytes(message.blockchainId);
        }
        Object.entries(message.shardToMaxOffsetMap).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.GetChainTipResponse_ShardToMaxOffsetMapEntry.encode({ key: key, value: value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetChainTipResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    var entry2 = exports.GetChainTipResponse_ShardToMaxOffsetMapEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.shardToMaxOffsetMap[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
            shardToMaxOffsetMap: isObject(object.shardToMaxOffsetMap)
                ? Object.entries(object.shardToMaxOffsetMap).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[globalThis.Number(key)] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        if (message.shardToMaxOffsetMap) {
            var entries = Object.entries(message.shardToMaxOffsetMap);
            if (entries.length > 0) {
                obj.shardToMaxOffsetMap = {};
                entries.forEach(function (_a) {
                    var k = _a[0], v = _a[1];
                    obj.shardToMaxOffsetMap[k] = v;
                });
            }
        }
        return obj;
    },
    create: function (base) {
        return exports.GetChainTipResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseGetChainTipResponse();
        message.blockchainId = (_a = object.blockchainId) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.shardToMaxOffsetMap = Object.entries((_b = object.shardToMaxOffsetMap) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[globalThis.Number(key)] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseGetChainTipResponse_ShardToMaxOffsetMapEntry() {
    return { key: 0, value: "0" };
}
exports.GetChainTipResponse_ShardToMaxOffsetMapEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.key !== 0) {
            writer.uint32(8).int32(message.key);
        }
        if (message.value !== "0") {
            writer.uint32(16).int64(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetChainTipResponse_ShardToMaxOffsetMapEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.key = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.int64().toString();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? globalThis.Number(object.key) : 0,
            value: isSet(object.value) ? globalThis.String(object.value) : "0",
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.key !== 0) {
            obj.key = Math.round(message.key);
        }
        if (message.value !== "0") {
            obj.value = message.value;
        }
        return obj;
    },
    create: function (base) {
        return exports.GetChainTipResponse_ShardToMaxOffsetMapEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseGetChainTipResponse_ShardToMaxOffsetMapEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "0";
        return message;
    },
};
function createBaseVersionRequest() {
    return {};
}
exports.VersionRequest = {
    encode: function (_, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseVersionRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (_) {
        return {};
    },
    toJSON: function (_) {
        var obj = {};
        return obj;
    },
    create: function (base) {
        return exports.VersionRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (_) {
        var message = createBaseVersionRequest();
        return message;
    },
};
function createBaseVersionResponse() {
    return { version: "" };
}
exports.VersionResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.version !== "") {
            writer.uint32(10).string(message.version);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseVersionResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { version: isSet(object.version) ? globalThis.String(object.version) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.version !== "") {
            obj.version = message.version;
        }
        return obj;
    },
    create: function (base) {
        return exports.VersionResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseVersionResponse();
        message.version = (_a = object.version) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseGetConsumerGroupInfoRequest() {
    return { consumerGroupName: "" };
}
exports.GetConsumerGroupInfoRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.consumerGroupName !== "") {
            writer.uint32(10).string(message.consumerGroupName);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetConsumerGroupInfoRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroupName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.consumerGroupName !== "") {
            obj.consumerGroupName = message.consumerGroupName;
        }
        return obj;
    },
    create: function (base) {
        return exports.GetConsumerGroupInfoRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseGetConsumerGroupInfoRequest();
        message.consumerGroupName = (_a = object.consumerGroupName) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseDeleteConsumerGroupRequest() {
    return { consumerGroupName: "" };
}
exports.DeleteConsumerGroupRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.consumerGroupName !== "") {
            writer.uint32(10).string(message.consumerGroupName);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDeleteConsumerGroupRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroupName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.consumerGroupName !== "") {
            obj.consumerGroupName = message.consumerGroupName;
        }
        return obj;
    },
    create: function (base) {
        return exports.DeleteConsumerGroupRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseDeleteConsumerGroupRequest();
        message.consumerGroupName = (_a = object.consumerGroupName) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseDeleteConsumerGroupResponse() {
    return { success: false };
}
exports.DeleteConsumerGroupResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDeleteConsumerGroupResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        return obj;
    },
    create: function (base) {
        return exports.DeleteConsumerGroupResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseDeleteConsumerGroupResponse();
        message.success = (_a = object.success) !== null && _a !== void 0 ? _a : false;
        return message;
    },
};
function createBaseListConsumerGroupsRequest() {
    return {};
}
exports.ListConsumerGroupsRequest = {
    encode: function (_, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseListConsumerGroupsRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (_) {
        return {};
    },
    toJSON: function (_) {
        var obj = {};
        return obj;
    },
    create: function (base) {
        return exports.ListConsumerGroupsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (_) {
        var message = createBaseListConsumerGroupsRequest();
        return message;
    },
};
function createBaseListConsumerGroupsResponse() {
    return { consumerGroups: [] };
}
exports.ListConsumerGroupsResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        for (var _i = 0, _a = message.consumerGroups; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.ConsumerGroupInfo.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseListConsumerGroupsResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroups.push(exports.ConsumerGroupInfo.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            consumerGroups: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.consumerGroups)
                ? object.consumerGroups.map(function (e) { return exports.ConsumerGroupInfo.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var _a;
        var obj = {};
        if ((_a = message.consumerGroups) === null || _a === void 0 ? void 0 : _a.length) {
            obj.consumerGroups = message.consumerGroups.map(function (e) { return exports.ConsumerGroupInfo.toJSON(e); });
        }
        return obj;
    },
    create: function (base) {
        return exports.ListConsumerGroupsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseListConsumerGroupsResponse();
        message.consumerGroups = ((_a = object.consumerGroups) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.ConsumerGroupInfo.fromPartial(e); })) || [];
        return message;
    },
};
function createBaseConsumerGroupInfo() {
    return { id: "", consumerGroupName: "", isStale: false, blockchainId: new Uint8Array(0) };
}
exports.ConsumerGroupInfo = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.consumerGroupName !== "") {
            writer.uint32(18).string(message.consumerGroupName);
        }
        if (message.isStale !== false) {
            writer.uint32(24).bool(message.isStale);
        }
        if (message.blockchainId.length !== 0) {
            writer.uint32(34).bytes(message.blockchainId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseConsumerGroupInfo();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.consumerGroupName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.isStale = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "",
            isStale: isSet(object.isStale) ? globalThis.Boolean(object.isStale) : false,
            blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.consumerGroupName !== "") {
            obj.consumerGroupName = message.consumerGroupName;
        }
        if (message.isStale !== false) {
            obj.isStale = message.isStale;
        }
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        return obj;
    },
    create: function (base) {
        return exports.ConsumerGroupInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseConsumerGroupInfo();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
        message.consumerGroupName = (_b = object.consumerGroupName) !== null && _b !== void 0 ? _b : "";
        message.isStale = (_c = object.isStale) !== null && _c !== void 0 ? _c : false;
        message.blockchainId = (_d = object.blockchainId) !== null && _d !== void 0 ? _d : new Uint8Array(0);
        return message;
    },
};
function createBaseGetSlotLagInfoRequest() {
    return { consumerGroupName: "" };
}
exports.GetSlotLagInfoRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.consumerGroupName !== "") {
            writer.uint32(10).string(message.consumerGroupName);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseGetSlotLagInfoRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroupName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.consumerGroupName !== "") {
            obj.consumerGroupName = message.consumerGroupName;
        }
        return obj;
    },
    create: function (base) {
        return exports.GetSlotLagInfoRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseGetSlotLagInfoRequest();
        message.consumerGroupName = (_a = object.consumerGroupName) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseBlockFilters() {
    return { accounts: {}, transactions: {}, entries: {}, blocksMeta: {} };
}
exports.BlockFilters = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        Object.entries(message.accounts).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.BlockFilters_AccountsEntry.encode({ key: key, value: value }, writer.uint32(10).fork()).join();
        });
        Object.entries(message.transactions).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.BlockFilters_TransactionsEntry.encode({ key: key, value: value }, writer.uint32(18).fork()).join();
        });
        Object.entries(message.entries).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.BlockFilters_EntriesEntry.encode({ key: key, value: value }, writer.uint32(26).fork()).join();
        });
        Object.entries(message.blocksMeta).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.BlockFilters_BlocksMetaEntry.encode({ key: key, value: value }, writer.uint32(34).fork()).join();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockFilters();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    var entry1 = exports.BlockFilters_AccountsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.accounts[entry1.key] = entry1.value;
                    }
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    var entry2 = exports.BlockFilters_TransactionsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.transactions[entry2.key] = entry2.value;
                    }
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    var entry3 = exports.BlockFilters_EntriesEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.entries[entry3.key] = entry3.value;
                    }
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    var entry4 = exports.BlockFilters_BlocksMetaEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.blocksMeta[entry4.key] = entry4.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            accounts: isObject(object.accounts)
                ? Object.entries(object.accounts).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = geyser_1.SubscribeRequestFilterAccounts.fromJSON(value);
                    return acc;
                }, {})
                : {},
            transactions: isObject(object.transactions)
                ? Object.entries(object.transactions).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = geyser_1.SubscribeRequestFilterTransactions.fromJSON(value);
                    return acc;
                }, {})
                : {},
            entries: isObject(object.entries)
                ? Object.entries(object.entries).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = geyser_1.SubscribeRequestFilterEntry.fromJSON(value);
                    return acc;
                }, {})
                : {},
            blocksMeta: isObject(object.blocksMeta)
                ? Object.entries(object.blocksMeta).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[key] = geyser_1.SubscribeRequestFilterBlocksMeta.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.accounts) {
            var entries = Object.entries(message.accounts);
            if (entries.length > 0) {
                obj.accounts = {};
                entries.forEach(function (_a) {
                    var k = _a[0], v = _a[1];
                    obj.accounts[k] = geyser_1.SubscribeRequestFilterAccounts.toJSON(v);
                });
            }
        }
        if (message.transactions) {
            var entries = Object.entries(message.transactions);
            if (entries.length > 0) {
                obj.transactions = {};
                entries.forEach(function (_a) {
                    var k = _a[0], v = _a[1];
                    obj.transactions[k] = geyser_1.SubscribeRequestFilterTransactions.toJSON(v);
                });
            }
        }
        if (message.entries) {
            var entries = Object.entries(message.entries);
            if (entries.length > 0) {
                obj.entries = {};
                entries.forEach(function (_a) {
                    var k = _a[0], v = _a[1];
                    obj.entries[k] = geyser_1.SubscribeRequestFilterEntry.toJSON(v);
                });
            }
        }
        if (message.blocksMeta) {
            var entries = Object.entries(message.blocksMeta);
            if (entries.length > 0) {
                obj.blocksMeta = {};
                entries.forEach(function (_a) {
                    var k = _a[0], v = _a[1];
                    obj.blocksMeta[k] = geyser_1.SubscribeRequestFilterBlocksMeta.toJSON(v);
                });
            }
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockFilters.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d;
        var message = createBaseBlockFilters();
        message.accounts = Object.entries((_a = object.accounts) !== null && _a !== void 0 ? _a : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = geyser_1.SubscribeRequestFilterAccounts.fromPartial(value);
            }
            return acc;
        }, {});
        message.transactions = Object.entries((_b = object.transactions) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = geyser_1.SubscribeRequestFilterTransactions.fromPartial(value);
            }
            return acc;
        }, {});
        message.entries = Object.entries((_c = object.entries) !== null && _c !== void 0 ? _c : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = geyser_1.SubscribeRequestFilterEntry.fromPartial(value);
            }
            return acc;
        }, {});
        message.blocksMeta = Object.entries((_d = object.blocksMeta) !== null && _d !== void 0 ? _d : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[key] = geyser_1.SubscribeRequestFilterBlocksMeta.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseBlockFilters_AccountsEntry() {
    return { key: "", value: undefined };
}
exports.BlockFilters_AccountsEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            geyser_1.SubscribeRequestFilterAccounts.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockFilters_AccountsEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = geyser_1.SubscribeRequestFilterAccounts.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? geyser_1.SubscribeRequestFilterAccounts.fromJSON(object.value) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = geyser_1.SubscribeRequestFilterAccounts.toJSON(message.value);
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockFilters_AccountsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseBlockFilters_AccountsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? geyser_1.SubscribeRequestFilterAccounts.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseBlockFilters_TransactionsEntry() {
    return { key: "", value: undefined };
}
exports.BlockFilters_TransactionsEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            geyser_1.SubscribeRequestFilterTransactions.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockFilters_TransactionsEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = geyser_1.SubscribeRequestFilterTransactions.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? geyser_1.SubscribeRequestFilterTransactions.fromJSON(object.value) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = geyser_1.SubscribeRequestFilterTransactions.toJSON(message.value);
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockFilters_TransactionsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseBlockFilters_TransactionsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? geyser_1.SubscribeRequestFilterTransactions.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseBlockFilters_EntriesEntry() {
    return { key: "", value: undefined };
}
exports.BlockFilters_EntriesEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            geyser_1.SubscribeRequestFilterEntry.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockFilters_EntriesEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = geyser_1.SubscribeRequestFilterEntry.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? geyser_1.SubscribeRequestFilterEntry.fromJSON(object.value) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = geyser_1.SubscribeRequestFilterEntry.toJSON(message.value);
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockFilters_EntriesEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseBlockFilters_EntriesEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? geyser_1.SubscribeRequestFilterEntry.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseBlockFilters_BlocksMetaEntry() {
    return { key: "", value: undefined };
}
exports.BlockFilters_BlocksMetaEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            geyser_1.SubscribeRequestFilterBlocksMeta.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockFilters_BlocksMetaEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = geyser_1.SubscribeRequestFilterBlocksMeta.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? geyser_1.SubscribeRequestFilterBlocksMeta.fromJSON(object.value) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = geyser_1.SubscribeRequestFilterBlocksMeta.toJSON(message.value);
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockFilters_BlocksMetaEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseBlockFilters_BlocksMetaEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (object.value !== undefined && object.value !== null)
            ? geyser_1.SubscribeRequestFilterBlocksMeta.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseDownloadBlockShard() {
    return { blockchainId: new Uint8Array(0), blockUid: new Uint8Array(0), shardIdx: 0, blockFilters: undefined };
}
exports.DownloadBlockShard = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.blockchainId.length !== 0) {
            writer.uint32(10).bytes(message.blockchainId);
        }
        if (message.blockUid.length !== 0) {
            writer.uint32(18).bytes(message.blockUid);
        }
        if (message.shardIdx !== 0) {
            writer.uint32(24).int32(message.shardIdx);
        }
        if (message.blockFilters !== undefined) {
            exports.BlockFilters.encode(message.blockFilters, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDownloadBlockShard();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.blockUid = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.shardIdx = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.blockFilters = exports.BlockFilters.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
            blockUid: isSet(object.blockUid) ? bytesFromBase64(object.blockUid) : new Uint8Array(0),
            shardIdx: isSet(object.shardIdx) ? globalThis.Number(object.shardIdx) : 0,
            blockFilters: isSet(object.blockFilters) ? exports.BlockFilters.fromJSON(object.blockFilters) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        if (message.blockUid.length !== 0) {
            obj.blockUid = base64FromBytes(message.blockUid);
        }
        if (message.shardIdx !== 0) {
            obj.shardIdx = Math.round(message.shardIdx);
        }
        if (message.blockFilters !== undefined) {
            obj.blockFilters = exports.BlockFilters.toJSON(message.blockFilters);
        }
        return obj;
    },
    create: function (base) {
        return exports.DownloadBlockShard.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseDownloadBlockShard();
        message.blockchainId = (_a = object.blockchainId) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.blockUid = (_b = object.blockUid) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.shardIdx = (_c = object.shardIdx) !== null && _c !== void 0 ? _c : 0;
        message.blockFilters = (object.blockFilters !== undefined && object.blockFilters !== null)
            ? exports.BlockFilters.fromPartial(object.blockFilters)
            : undefined;
        return message;
    },
};
function createBasePing() {
    return { pingId: 0 };
}
exports.Ping = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.pingId !== 0) {
            writer.uint32(8).uint32(message.pingId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePing();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.pingId = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.pingId !== 0) {
            obj.pingId = Math.round(message.pingId);
        }
        return obj;
    },
    create: function (base) {
        return exports.Ping.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasePing();
        message.pingId = (_a = object.pingId) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBasePong() {
    return { pingId: 0 };
}
exports.Pong = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.pingId !== 0) {
            writer.uint32(8).uint32(message.pingId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePong();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.pingId = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { pingId: isSet(object.pingId) ? globalThis.Number(object.pingId) : 0 };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.pingId !== 0) {
            obj.pingId = Math.round(message.pingId);
        }
        return obj;
    },
    create: function (base) {
        return exports.Pong.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBasePong();
        message.pingId = (_a = object.pingId) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseDataCommand() {
    return { downloadBlockShard: undefined, filterUpdate: undefined };
}
exports.DataCommand = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.downloadBlockShard !== undefined) {
            exports.DownloadBlockShard.encode(message.downloadBlockShard, writer.uint32(10).fork()).join();
        }
        if (message.filterUpdate !== undefined) {
            exports.BlockFilters.encode(message.filterUpdate, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDataCommand();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.downloadBlockShard = exports.DownloadBlockShard.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.filterUpdate = exports.BlockFilters.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            downloadBlockShard: isSet(object.downloadBlockShard)
                ? exports.DownloadBlockShard.fromJSON(object.downloadBlockShard)
                : undefined,
            filterUpdate: isSet(object.filterUpdate) ? exports.BlockFilters.fromJSON(object.filterUpdate) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.downloadBlockShard !== undefined) {
            obj.downloadBlockShard = exports.DownloadBlockShard.toJSON(message.downloadBlockShard);
        }
        if (message.filterUpdate !== undefined) {
            obj.filterUpdate = exports.BlockFilters.toJSON(message.filterUpdate);
        }
        return obj;
    },
    create: function (base) {
        return exports.DataCommand.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseDataCommand();
        message.downloadBlockShard = (object.downloadBlockShard !== undefined && object.downloadBlockShard !== null)
            ? exports.DownloadBlockShard.fromPartial(object.downloadBlockShard)
            : undefined;
        message.filterUpdate = (object.filterUpdate !== undefined && object.filterUpdate !== null)
            ? exports.BlockFilters.fromPartial(object.filterUpdate)
            : undefined;
        return message;
    },
};
function createBaseBlockShardDownloadFinish() {
    return {};
}
exports.BlockShardDownloadFinish = {
    encode: function (_, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockShardDownloadFinish();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (_) {
        return {};
    },
    toJSON: function (_) {
        var obj = {};
        return obj;
    },
    create: function (base) {
        return exports.BlockShardDownloadFinish.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (_) {
        var message = createBaseBlockShardDownloadFinish();
        return message;
    },
};
function createBaseBlockNotFound() {
    return { blockchainId: new Uint8Array(0), blockUid: new Uint8Array(0), shardIdx: 0 };
}
exports.BlockNotFound = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.blockchainId.length !== 0) {
            writer.uint32(10).bytes(message.blockchainId);
        }
        if (message.blockUid.length !== 0) {
            writer.uint32(18).bytes(message.blockUid);
        }
        if (message.shardIdx !== 0) {
            writer.uint32(24).int32(message.shardIdx);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockNotFound();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.blockUid = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.shardIdx = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
            blockUid: isSet(object.blockUid) ? bytesFromBase64(object.blockUid) : new Uint8Array(0),
            shardIdx: isSet(object.shardIdx) ? globalThis.Number(object.shardIdx) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        if (message.blockUid.length !== 0) {
            obj.blockUid = base64FromBytes(message.blockUid);
        }
        if (message.shardIdx !== 0) {
            obj.shardIdx = Math.round(message.shardIdx);
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockNotFound.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBaseBlockNotFound();
        message.blockchainId = (_a = object.blockchainId) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.blockUid = (_b = object.blockUid) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.shardIdx = (_c = object.shardIdx) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseDataError() {
    return { notFound: undefined };
}
exports.DataError = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.notFound !== undefined) {
            exports.BlockNotFound.encode(message.notFound, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDataError();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.notFound = exports.BlockNotFound.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { notFound: isSet(object.notFound) ? exports.BlockNotFound.fromJSON(object.notFound) : undefined };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.notFound !== undefined) {
            obj.notFound = exports.BlockNotFound.toJSON(message.notFound);
        }
        return obj;
    },
    create: function (base) {
        return exports.DataError.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseDataError();
        message.notFound = (object.notFound !== undefined && object.notFound !== null)
            ? exports.BlockNotFound.fromPartial(object.notFound)
            : undefined;
        return message;
    },
};
function createBaseDataResponse() {
    return { update: undefined, blockShardDownloadFinish: undefined };
}
exports.DataResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.update !== undefined) {
            geyser_1.SubscribeUpdate.encode(message.update, writer.uint32(10).fork()).join();
        }
        if (message.blockShardDownloadFinish !== undefined) {
            exports.BlockShardDownloadFinish.encode(message.blockShardDownloadFinish, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseDataResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.update = geyser_1.SubscribeUpdate.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.blockShardDownloadFinish = exports.BlockShardDownloadFinish.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            update: isSet(object.update) ? geyser_1.SubscribeUpdate.fromJSON(object.update) : undefined,
            blockShardDownloadFinish: isSet(object.blockShardDownloadFinish)
                ? exports.BlockShardDownloadFinish.fromJSON(object.blockShardDownloadFinish)
                : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.update !== undefined) {
            obj.update = geyser_1.SubscribeUpdate.toJSON(message.update);
        }
        if (message.blockShardDownloadFinish !== undefined) {
            obj.blockShardDownloadFinish = exports.BlockShardDownloadFinish.toJSON(message.blockShardDownloadFinish);
        }
        return obj;
    },
    create: function (base) {
        return exports.DataResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseDataResponse();
        message.update = (object.update !== undefined && object.update !== null)
            ? geyser_1.SubscribeUpdate.fromPartial(object.update)
            : undefined;
        message.blockShardDownloadFinish =
            (object.blockShardDownloadFinish !== undefined && object.blockShardDownloadFinish !== null)
                ? exports.BlockShardDownloadFinish.fromPartial(object.blockShardDownloadFinish)
                : undefined;
        return message;
    },
};
function createBaseCommitOffset() {
    return { offset: "0", shardId: 0 };
}
exports.CommitOffset = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.offset !== "0") {
            writer.uint32(8).int64(message.offset);
        }
        if (message.shardId !== 0) {
            writer.uint32(16).int32(message.shardId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCommitOffset();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.offset = reader.int64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.shardId = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
            shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.offset !== "0") {
            obj.offset = message.offset;
        }
        if (message.shardId !== 0) {
            obj.shardId = Math.round(message.shardId);
        }
        return obj;
    },
    create: function (base) {
        return exports.CommitOffset.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseCommitOffset();
        message.offset = (_a = object.offset) !== null && _a !== void 0 ? _a : "0";
        message.shardId = (_b = object.shardId) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBasePollBlockchainHistory() {
    return { shardId: 0, from: undefined, limit: undefined };
}
exports.PollBlockchainHistory = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.shardId !== 0) {
            writer.uint32(8).int32(message.shardId);
        }
        if (message.from !== undefined) {
            writer.uint32(16).int64(message.from);
        }
        if (message.limit !== undefined) {
            writer.uint32(24).int64(message.limit);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBasePollBlockchainHistory();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.shardId = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.from = reader.int64().toString();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.limit = reader.int64().toString();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
            from: isSet(object.from) ? globalThis.String(object.from) : undefined,
            limit: isSet(object.limit) ? globalThis.String(object.limit) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.shardId !== 0) {
            obj.shardId = Math.round(message.shardId);
        }
        if (message.from !== undefined) {
            obj.from = message.from;
        }
        if (message.limit !== undefined) {
            obj.limit = message.limit;
        }
        return obj;
    },
    create: function (base) {
        return exports.PollBlockchainHistory.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c;
        var message = createBasePollBlockchainHistory();
        message.shardId = (_a = object.shardId) !== null && _a !== void 0 ? _a : 0;
        message.from = (_b = object.from) !== null && _b !== void 0 ? _b : undefined;
        message.limit = (_c = object.limit) !== null && _c !== void 0 ? _c : undefined;
        return message;
    },
};
function createBaseBlockchainEvent() {
    return {
        offset: "0",
        blockchainId: new Uint8Array(0),
        blockUid: new Uint8Array(0),
        numShards: 0,
        slot: "0",
        parentSlot: undefined,
        commitmentLevel: 0,
        blockchainShardId: 0,
        deadError: undefined,
    };
}
exports.BlockchainEvent = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.offset !== "0") {
            writer.uint32(8).int64(message.offset);
        }
        if (message.blockchainId.length !== 0) {
            writer.uint32(18).bytes(message.blockchainId);
        }
        if (message.blockUid.length !== 0) {
            writer.uint32(26).bytes(message.blockUid);
        }
        if (message.numShards !== 0) {
            writer.uint32(32).uint32(message.numShards);
        }
        if (message.slot !== "0") {
            writer.uint32(40).uint64(message.slot);
        }
        if (message.parentSlot !== undefined) {
            writer.uint32(48).uint64(message.parentSlot);
        }
        if (message.commitmentLevel !== 0) {
            writer.uint32(56).int32(message.commitmentLevel);
        }
        if (message.blockchainShardId !== 0) {
            writer.uint32(64).int32(message.blockchainShardId);
        }
        if (message.deadError !== undefined) {
            writer.uint32(74).string(message.deadError);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockchainEvent();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.offset = reader.int64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.blockUid = reader.bytes();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.numShards = reader.uint32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.slot = reader.uint64().toString();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.parentSlot = reader.uint64().toString();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.commitmentLevel = reader.int32();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.blockchainShardId = reader.int32();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.deadError = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
            blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
            blockUid: isSet(object.blockUid) ? bytesFromBase64(object.blockUid) : new Uint8Array(0),
            numShards: isSet(object.numShards) ? globalThis.Number(object.numShards) : 0,
            slot: isSet(object.slot) ? globalThis.String(object.slot) : "0",
            parentSlot: isSet(object.parentSlot) ? globalThis.String(object.parentSlot) : undefined,
            commitmentLevel: isSet(object.commitmentLevel) ? (0, geyser_1.commitmentLevelFromJSON)(object.commitmentLevel) : 0,
            blockchainShardId: isSet(object.blockchainShardId) ? globalThis.Number(object.blockchainShardId) : 0,
            deadError: isSet(object.deadError) ? globalThis.String(object.deadError) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.offset !== "0") {
            obj.offset = message.offset;
        }
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        if (message.blockUid.length !== 0) {
            obj.blockUid = base64FromBytes(message.blockUid);
        }
        if (message.numShards !== 0) {
            obj.numShards = Math.round(message.numShards);
        }
        if (message.slot !== "0") {
            obj.slot = message.slot;
        }
        if (message.parentSlot !== undefined) {
            obj.parentSlot = message.parentSlot;
        }
        if (message.commitmentLevel !== 0) {
            obj.commitmentLevel = (0, geyser_1.commitmentLevelToJSON)(message.commitmentLevel);
        }
        if (message.blockchainShardId !== 0) {
            obj.blockchainShardId = Math.round(message.blockchainShardId);
        }
        if (message.deadError !== undefined) {
            obj.deadError = message.deadError;
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockchainEvent.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var message = createBaseBlockchainEvent();
        message.offset = (_a = object.offset) !== null && _a !== void 0 ? _a : "0";
        message.blockchainId = (_b = object.blockchainId) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.blockUid = (_c = object.blockUid) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.numShards = (_d = object.numShards) !== null && _d !== void 0 ? _d : 0;
        message.slot = (_e = object.slot) !== null && _e !== void 0 ? _e : "0";
        message.parentSlot = (_f = object.parentSlot) !== null && _f !== void 0 ? _f : undefined;
        message.commitmentLevel = (_g = object.commitmentLevel) !== null && _g !== void 0 ? _g : 0;
        message.blockchainShardId = (_h = object.blockchainShardId) !== null && _h !== void 0 ? _h : 0;
        message.deadError = (_j = object.deadError) !== null && _j !== void 0 ? _j : undefined;
        return message;
    },
};
function createBaseBlockchainHistory() {
    return { events: [] };
}
exports.BlockchainHistory = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        for (var _i = 0, _a = message.events; _i < _a.length; _i++) {
            var v = _a[_i];
            exports.BlockchainEvent.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseBlockchainHistory();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.events.push(exports.BlockchainEvent.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            events: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.events)
                ? object.events.map(function (e) { return exports.BlockchainEvent.fromJSON(e); })
                : [],
        };
    },
    toJSON: function (message) {
        var _a;
        var obj = {};
        if ((_a = message.events) === null || _a === void 0 ? void 0 : _a.length) {
            obj.events = message.events.map(function (e) { return exports.BlockchainEvent.toJSON(e); });
        }
        return obj;
    },
    create: function (base) {
        return exports.BlockchainHistory.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseBlockchainHistory();
        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map(function (e) { return exports.BlockchainEvent.fromPartial(e); })) || [];
        return message;
    },
};
function createBaseJoinControlPlane() {
    return { consumerGroupName: undefined };
}
exports.JoinControlPlane = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.consumerGroupName !== undefined) {
            writer.uint32(10).string(message.consumerGroupName);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseJoinControlPlane();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroupName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.consumerGroupName !== undefined) {
            obj.consumerGroupName = message.consumerGroupName;
        }
        return obj;
    },
    create: function (base) {
        return exports.JoinControlPlane.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseJoinControlPlane();
        message.consumerGroupName = (_a = object.consumerGroupName) !== null && _a !== void 0 ? _a : undefined;
        return message;
    },
};
function createBaseControlCommand() {
    return { initialJoin: undefined, commitOffset: undefined, pollHist: undefined, ping: undefined };
}
exports.ControlCommand = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.initialJoin !== undefined) {
            exports.JoinControlPlane.encode(message.initialJoin, writer.uint32(10).fork()).join();
        }
        if (message.commitOffset !== undefined) {
            exports.CommitOffset.encode(message.commitOffset, writer.uint32(18).fork()).join();
        }
        if (message.pollHist !== undefined) {
            exports.PollBlockchainHistory.encode(message.pollHist, writer.uint32(26).fork()).join();
        }
        if (message.ping !== undefined) {
            exports.Ping.encode(message.ping, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseControlCommand();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.initialJoin = exports.JoinControlPlane.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.commitOffset = exports.CommitOffset.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.pollHist = exports.PollBlockchainHistory.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.ping = exports.Ping.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            initialJoin: isSet(object.initialJoin) ? exports.JoinControlPlane.fromJSON(object.initialJoin) : undefined,
            commitOffset: isSet(object.commitOffset) ? exports.CommitOffset.fromJSON(object.commitOffset) : undefined,
            pollHist: isSet(object.pollHist) ? exports.PollBlockchainHistory.fromJSON(object.pollHist) : undefined,
            ping: isSet(object.ping) ? exports.Ping.fromJSON(object.ping) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.initialJoin !== undefined) {
            obj.initialJoin = exports.JoinControlPlane.toJSON(message.initialJoin);
        }
        if (message.commitOffset !== undefined) {
            obj.commitOffset = exports.CommitOffset.toJSON(message.commitOffset);
        }
        if (message.pollHist !== undefined) {
            obj.pollHist = exports.PollBlockchainHistory.toJSON(message.pollHist);
        }
        if (message.ping !== undefined) {
            obj.ping = exports.Ping.toJSON(message.ping);
        }
        return obj;
    },
    create: function (base) {
        return exports.ControlCommand.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseControlCommand();
        message.initialJoin = (object.initialJoin !== undefined && object.initialJoin !== null)
            ? exports.JoinControlPlane.fromPartial(object.initialJoin)
            : undefined;
        message.commitOffset = (object.commitOffset !== undefined && object.commitOffset !== null)
            ? exports.CommitOffset.fromPartial(object.commitOffset)
            : undefined;
        message.pollHist = (object.pollHist !== undefined && object.pollHist !== null)
            ? exports.PollBlockchainHistory.fromPartial(object.pollHist)
            : undefined;
        message.ping = (object.ping !== undefined && object.ping !== null) ? exports.Ping.fromPartial(object.ping) : undefined;
        return message;
    },
};
function createBaseControlResponse() {
    return { init: undefined, commitOffset: undefined, pollHist: undefined, pong: undefined };
}
exports.ControlResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.init !== undefined) {
            exports.InitialConsumerGroupState.encode(message.init, writer.uint32(10).fork()).join();
        }
        if (message.commitOffset !== undefined) {
            exports.CommitOffsetResult.encode(message.commitOffset, writer.uint32(18).fork()).join();
        }
        if (message.pollHist !== undefined) {
            exports.BlockchainHistory.encode(message.pollHist, writer.uint32(26).fork()).join();
        }
        if (message.pong !== undefined) {
            exports.Pong.encode(message.pong, writer.uint32(34).fork()).join();
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseControlResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.init = exports.InitialConsumerGroupState.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.commitOffset = exports.CommitOffsetResult.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.pollHist = exports.BlockchainHistory.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.pong = exports.Pong.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            init: isSet(object.init) ? exports.InitialConsumerGroupState.fromJSON(object.init) : undefined,
            commitOffset: isSet(object.commitOffset) ? exports.CommitOffsetResult.fromJSON(object.commitOffset) : undefined,
            pollHist: isSet(object.pollHist) ? exports.BlockchainHistory.fromJSON(object.pollHist) : undefined,
            pong: isSet(object.pong) ? exports.Pong.fromJSON(object.pong) : undefined,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.init !== undefined) {
            obj.init = exports.InitialConsumerGroupState.toJSON(message.init);
        }
        if (message.commitOffset !== undefined) {
            obj.commitOffset = exports.CommitOffsetResult.toJSON(message.commitOffset);
        }
        if (message.pollHist !== undefined) {
            obj.pollHist = exports.BlockchainHistory.toJSON(message.pollHist);
        }
        if (message.pong !== undefined) {
            obj.pong = exports.Pong.toJSON(message.pong);
        }
        return obj;
    },
    create: function (base) {
        return exports.ControlResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var message = createBaseControlResponse();
        message.init = (object.init !== undefined && object.init !== null)
            ? exports.InitialConsumerGroupState.fromPartial(object.init)
            : undefined;
        message.commitOffset = (object.commitOffset !== undefined && object.commitOffset !== null)
            ? exports.CommitOffsetResult.fromPartial(object.commitOffset)
            : undefined;
        message.pollHist = (object.pollHist !== undefined && object.pollHist !== null)
            ? exports.BlockchainHistory.fromPartial(object.pollHist)
            : undefined;
        message.pong = (object.pong !== undefined && object.pong !== null) ? exports.Pong.fromPartial(object.pong) : undefined;
        return message;
    },
};
function createBaseCommitOffsetResult() {
    return { offset: "0", shardId: 0 };
}
exports.CommitOffsetResult = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.offset !== "0") {
            writer.uint32(8).int64(message.offset);
        }
        if (message.shardId !== 0) {
            writer.uint32(16).int32(message.shardId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCommitOffsetResult();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.offset = reader.int64().toString();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.shardId = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            offset: isSet(object.offset) ? globalThis.String(object.offset) : "0",
            shardId: isSet(object.shardId) ? globalThis.Number(object.shardId) : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.offset !== "0") {
            obj.offset = message.offset;
        }
        if (message.shardId !== 0) {
            obj.shardId = Math.round(message.shardId);
        }
        return obj;
    },
    create: function (base) {
        return exports.CommitOffsetResult.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseCommitOffsetResult();
        message.offset = (_a = object.offset) !== null && _a !== void 0 ? _a : "0";
        message.shardId = (_b = object.shardId) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseInitialConsumerGroupState() {
    return { blockchainId: new Uint8Array(0), lastCommittedOffsets: {} };
}
exports.InitialConsumerGroupState = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.blockchainId.length !== 0) {
            writer.uint32(10).bytes(message.blockchainId);
        }
        Object.entries(message.lastCommittedOffsets).forEach(function (_a) {
            var key = _a[0], value = _a[1];
            exports.InitialConsumerGroupState_LastCommittedOffsetsEntry.encode({ key: key, value: value }, writer.uint32(18).fork())
                .join();
        });
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseInitialConsumerGroupState();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.blockchainId = reader.bytes();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    var entry2 = exports.InitialConsumerGroupState_LastCommittedOffsetsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.lastCommittedOffsets[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            blockchainId: isSet(object.blockchainId) ? bytesFromBase64(object.blockchainId) : new Uint8Array(0),
            lastCommittedOffsets: isObject(object.lastCommittedOffsets)
                ? Object.entries(object.lastCommittedOffsets).reduce(function (acc, _a) {
                    var key = _a[0], value = _a[1];
                    acc[globalThis.Number(key)] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.blockchainId.length !== 0) {
            obj.blockchainId = base64FromBytes(message.blockchainId);
        }
        if (message.lastCommittedOffsets) {
            var entries = Object.entries(message.lastCommittedOffsets);
            if (entries.length > 0) {
                obj.lastCommittedOffsets = {};
                entries.forEach(function (_a) {
                    var k = _a[0], v = _a[1];
                    obj.lastCommittedOffsets[k] = v;
                });
            }
        }
        return obj;
    },
    create: function (base) {
        return exports.InitialConsumerGroupState.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseInitialConsumerGroupState();
        message.blockchainId = (_a = object.blockchainId) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.lastCommittedOffsets = Object.entries((_b = object.lastCommittedOffsets) !== null && _b !== void 0 ? _b : {}).reduce(function (acc, _a) {
            var key = _a[0], value = _a[1];
            if (value !== undefined) {
                acc[globalThis.Number(key)] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseInitialConsumerGroupState_LastCommittedOffsetsEntry() {
    return { key: 0, value: "0" };
}
exports.InitialConsumerGroupState_LastCommittedOffsetsEntry = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.key !== 0) {
            writer.uint32(8).int32(message.key);
        }
        if (message.value !== "0") {
            writer.uint32(16).int64(message.value);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseInitialConsumerGroupState_LastCommittedOffsetsEntry();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.key = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.value = reader.int64().toString();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            key: isSet(object.key) ? globalThis.Number(object.key) : 0,
            value: isSet(object.value) ? globalThis.String(object.value) : "0",
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.key !== 0) {
            obj.key = Math.round(message.key);
        }
        if (message.value !== "0") {
            obj.value = message.value;
        }
        return obj;
    },
    create: function (base) {
        return exports.InitialConsumerGroupState_LastCommittedOffsetsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseInitialConsumerGroupState_LastCommittedOffsetsEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "0";
        return message;
    },
};
function createBaseCreateConsumerGroupResponse() {
    return { consumerGroupId: "" };
}
exports.CreateConsumerGroupResponse = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.consumerGroupId !== "") {
            writer.uint32(10).string(message.consumerGroupId);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCreateConsumerGroupResponse();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroupId = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return { consumerGroupId: isSet(object.consumerGroupId) ? globalThis.String(object.consumerGroupId) : "" };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.consumerGroupId !== "") {
            obj.consumerGroupId = message.consumerGroupId;
        }
        return obj;
    },
    create: function (base) {
        return exports.CreateConsumerGroupResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a;
        var message = createBaseCreateConsumerGroupResponse();
        message.consumerGroupId = (_a = object.consumerGroupId) !== null && _a !== void 0 ? _a : "";
        return message;
    },
};
function createBaseCreateConsumerGroupRequest() {
    return { consumerGroupName: "", initialOffsetPolicy: 0 };
}
exports.CreateConsumerGroupRequest = {
    encode: function (message, writer) {
        if (writer === void 0) { writer = new wire_1.BinaryWriter(); }
        if (message.consumerGroupName !== "") {
            writer.uint32(10).string(message.consumerGroupName);
        }
        if (message.initialOffsetPolicy !== 0) {
            writer.uint32(16).int32(message.initialOffsetPolicy);
        }
        return writer;
    },
    decode: function (input, length) {
        var reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        var end = length === undefined ? reader.len : reader.pos + length;
        var message = createBaseCreateConsumerGroupRequest();
        while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.consumerGroupName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.initialOffsetPolicy = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON: function (object) {
        return {
            consumerGroupName: isSet(object.consumerGroupName) ? globalThis.String(object.consumerGroupName) : "",
            initialOffsetPolicy: isSet(object.initialOffsetPolicy)
                ? initialOffsetPolicyFromJSON(object.initialOffsetPolicy)
                : 0,
        };
    },
    toJSON: function (message) {
        var obj = {};
        if (message.consumerGroupName !== "") {
            obj.consumerGroupName = message.consumerGroupName;
        }
        if (message.initialOffsetPolicy !== 0) {
            obj.initialOffsetPolicy = initialOffsetPolicyToJSON(message.initialOffsetPolicy);
        }
        return obj;
    },
    create: function (base) {
        return exports.CreateConsumerGroupRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial: function (object) {
        var _a, _b;
        var message = createBaseCreateConsumerGroupRequest();
        message.consumerGroupName = (_a = object.consumerGroupName) !== null && _a !== void 0 ? _a : "";
        message.initialOffsetPolicy = (_b = object.initialOffsetPolicy) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
exports.FumaroleService = {
    getConsumerGroupInfo: {
        path: "/fumarole.Fumarole/GetConsumerGroupInfo",
        requestStream: false,
        responseStream: false,
        requestSerialize: function (value) {
            return Buffer.from(exports.GetConsumerGroupInfoRequest.encode(value).finish());
        },
        requestDeserialize: function (value) { return exports.GetConsumerGroupInfoRequest.decode(value); },
        responseSerialize: function (value) { return Buffer.from(exports.ConsumerGroupInfo.encode(value).finish()); },
        responseDeserialize: function (value) { return exports.ConsumerGroupInfo.decode(value); },
    },
    listConsumerGroups: {
        path: "/fumarole.Fumarole/ListConsumerGroups",
        requestStream: false,
        responseStream: false,
        requestSerialize: function (value) {
            return Buffer.from(exports.ListConsumerGroupsRequest.encode(value).finish());
        },
        requestDeserialize: function (value) { return exports.ListConsumerGroupsRequest.decode(value); },
        responseSerialize: function (value) {
            return Buffer.from(exports.ListConsumerGroupsResponse.encode(value).finish());
        },
        responseDeserialize: function (value) { return exports.ListConsumerGroupsResponse.decode(value); },
    },
    deleteConsumerGroup: {
        path: "/fumarole.Fumarole/DeleteConsumerGroup",
        requestStream: false,
        responseStream: false,
        requestSerialize: function (value) {
            return Buffer.from(exports.DeleteConsumerGroupRequest.encode(value).finish());
        },
        requestDeserialize: function (value) { return exports.DeleteConsumerGroupRequest.decode(value); },
        responseSerialize: function (value) {
            return Buffer.from(exports.DeleteConsumerGroupResponse.encode(value).finish());
        },
        responseDeserialize: function (value) { return exports.DeleteConsumerGroupResponse.decode(value); },
    },
    createConsumerGroup: {
        path: "/fumarole.Fumarole/CreateConsumerGroup",
        requestStream: false,
        responseStream: false,
        requestSerialize: function (value) {
            return Buffer.from(exports.CreateConsumerGroupRequest.encode(value).finish());
        },
        requestDeserialize: function (value) { return exports.CreateConsumerGroupRequest.decode(value); },
        responseSerialize: function (value) {
            return Buffer.from(exports.CreateConsumerGroupResponse.encode(value).finish());
        },
        responseDeserialize: function (value) { return exports.CreateConsumerGroupResponse.decode(value); },
    },
    downloadBlock: {
        path: "/fumarole.Fumarole/DownloadBlock",
        requestStream: false,
        responseStream: true,
        requestSerialize: function (value) { return Buffer.from(exports.DownloadBlockShard.encode(value).finish()); },
        requestDeserialize: function (value) { return exports.DownloadBlockShard.decode(value); },
        responseSerialize: function (value) { return Buffer.from(exports.DataResponse.encode(value).finish()); },
        responseDeserialize: function (value) { return exports.DataResponse.decode(value); },
    },
    /** Represents subscription to the data plane */
    subscribeData: {
        path: "/fumarole.Fumarole/SubscribeData",
        requestStream: true,
        responseStream: true,
        requestSerialize: function (value) { return Buffer.from(exports.DataCommand.encode(value).finish()); },
        requestDeserialize: function (value) { return exports.DataCommand.decode(value); },
        responseSerialize: function (value) { return Buffer.from(exports.DataResponse.encode(value).finish()); },
        responseDeserialize: function (value) { return exports.DataResponse.decode(value); },
    },
    getChainTip: {
        path: "/fumarole.Fumarole/GetChainTip",
        requestStream: false,
        responseStream: false,
        requestSerialize: function (value) { return Buffer.from(exports.GetChainTipRequest.encode(value).finish()); },
        requestDeserialize: function (value) { return exports.GetChainTipRequest.decode(value); },
        responseSerialize: function (value) { return Buffer.from(exports.GetChainTipResponse.encode(value).finish()); },
        responseDeserialize: function (value) { return exports.GetChainTipResponse.decode(value); },
    },
    /** Represents subscription to the control plane */
    subscribe: {
        path: "/fumarole.Fumarole/Subscribe",
        requestStream: true,
        responseStream: true,
        requestSerialize: function (value) { return Buffer.from(exports.ControlCommand.encode(value).finish()); },
        requestDeserialize: function (value) { return exports.ControlCommand.decode(value); },
        responseSerialize: function (value) { return Buffer.from(exports.ControlResponse.encode(value).finish()); },
        responseDeserialize: function (value) { return exports.ControlResponse.decode(value); },
    },
    version: {
        path: "/fumarole.Fumarole/Version",
        requestStream: false,
        responseStream: false,
        requestSerialize: function (value) { return Buffer.from(exports.VersionRequest.encode(value).finish()); },
        requestDeserialize: function (value) { return exports.VersionRequest.decode(value); },
        responseSerialize: function (value) { return Buffer.from(exports.VersionResponse.encode(value).finish()); },
        responseDeserialize: function (value) { return exports.VersionResponse.decode(value); },
    },
};
exports.FumaroleClient = (0, grpc_js_1.makeGenericClientConstructor)(exports.FumaroleService, "fumarole.Fumarole");
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        var bin = globalThis.atob(b64);
        var arr = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        var bin_1 = [];
        arr.forEach(function (byte) {
            bin_1.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin_1.join(""));
    }
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
